"use strict";
var _a, _b;
Object.defineProperty(exports, "__esModule", { value: true });
exports.StackOutput = exports.CdkStage = void 0;
const JSII_RTTI_SYMBOL_1 = Symbol.for("jsii.rtti");
const cpactions = require("@aws-cdk/aws-codepipeline-actions");
const core_1 = require("@aws-cdk/core");
const actions_1 = require("./actions");
const asset_manifest_1 = require("./private/asset-manifest");
const toposort_1 = require("./private/toposort");
// v2 - keep this import as a separate section to reduce merge conflict when forward merging with the v2 branch.
// eslint-disable-next-line
const core_2 = require("@aws-cdk/core");
/**
 * (experimental) Stage in a CdkPipeline.
 *
 * You don't need to instantiate this class directly. Use
 * `cdkPipeline.addStage()` instead.
 *
 * @experimental
 */
class CdkStage extends core_2.Construct {
    /**
     * @experimental
     */
    constructor(scope, id, props) {
        super(scope, id);
        this._nextSequentialRunOrder = 1; // Must start at 1 eh
        this._manualApprovalCounter = 1;
        this.stacksToDeploy = new Array();
        this._prepared = false;
        this.stageName = props.stageName;
        this.pipelineStage = props.pipelineStage;
        this.cloudAssemblyArtifact = props.cloudAssemblyArtifact;
        this.host = props.host;
        core_1.Aspects.of(this).add({ visit: () => this.prepareStage() });
    }
    /**
     * (experimental) Add all stacks in the application Stage to this stage.
     *
     * The application construct should subclass `Stage` and can contain any
     * number of `Stacks` inside it that may have dependency relationships
     * on one another.
     *
     * All stacks in the application will be deployed in the appropriate order,
     * and all assets found in the application will be added to the asset
     * publishing stage.
     *
     * @experimental
     */
    addApplication(appStage, options = {}) {
        var _c;
        const asm = appStage.synth({ validateOnSynthesis: true });
        const extraRunOrderSpace = (_c = options.extraRunOrderSpace) !== null && _c !== void 0 ? _c : 0;
        if (asm.stacks.length === 0) {
            // If we don't check here, a more puzzling "stage contains no actions"
            // error will be thrown come deployment time.
            throw new Error(`The given Stage construct ('${appStage.node.path}') should contain at least one Stack`);
        }
        const sortedTranches = toposort_1.topologicalSort(asm.stacks, stack => stack.id, stack => stack.dependencies.map(d => d.id));
        for (const stacks of sortedTranches) {
            const runOrder = this.nextSequentialRunOrder(extraRunOrderSpace + 2); // 2 actions for Prepare/Execute ChangeSet
            let executeRunOrder = runOrder + extraRunOrderSpace + 1;
            // If we need to insert a manual approval action, then what's the executeRunOrder
            // now is where we add a manual approval step, and we allocate 1 more runOrder
            // for the execute.
            if (options.manualApprovals) {
                this.addManualApprovalAction({ runOrder: runOrder + 1 });
                executeRunOrder = this.nextSequentialRunOrder();
            }
            // These don't have a dependency on each other, so can all be added in parallel
            for (const stack of stacks) {
                this.addStackArtifactDeployment(stack, { runOrder, executeRunOrder });
            }
        }
    }
    /**
     * (experimental) Add a deployment action based on a stack artifact.
     *
     * @experimental
     */
    addStackArtifactDeployment(stackArtifact, options = {}) {
        var _c, _d;
        // Get all assets manifests and add the assets in 'em to the asset publishing stage.
        this.publishAssetDependencies(stackArtifact);
        // Remember for later, see 'prepare()'
        // We know that deploying a stack is going to take up 2 runorder slots later on.
        const runOrder = (_c = options.runOrder) !== null && _c !== void 0 ? _c : this.nextSequentialRunOrder(2);
        const executeRunOrder = (_d = options.executeRunOrder) !== null && _d !== void 0 ? _d : runOrder + 1;
        this.stacksToDeploy.push({
            prepareRunOrder: runOrder,
            executeRunOrder,
            stackArtifact,
        });
        this.advanceRunOrderPast(runOrder);
        this.advanceRunOrderPast(executeRunOrder);
    }
    /**
     * (experimental) Add a manual approval action.
     *
     * If you need more flexibility than what this method offers,
     * use `addAction` with a `ManualApprovalAction`.
     *
     * @experimental
     */
    addManualApprovalAction(options = {}) {
        var _c;
        let actionName = options.actionName;
        if (!actionName) {
            actionName = `ManualApproval${this._manualApprovalCounter > 1 ? this._manualApprovalCounter : ''}`;
            this._manualApprovalCounter += 1;
        }
        this.addActions(new cpactions.ManualApprovalAction({
            actionName,
            runOrder: (_c = options.runOrder) !== null && _c !== void 0 ? _c : this.nextSequentialRunOrder(),
        }));
    }
    /**
     * (experimental) Add one or more CodePipeline Actions.
     *
     * You need to make sure it is created with the right runOrder. Call `nextSequentialRunOrder()`
     * for every action to get actions to execute in sequence.
     *
     * @experimental
     */
    addActions(...actions) {
        for (const action of actions) {
            this.pipelineStage.addAction(action);
        }
    }
    /**
     * (experimental) Return the runOrder number necessary to run the next Action in sequence with the rest.
     *
     * FIXME: This is here because Actions are immutable and can't be reordered
     * after creation, nor is there a way to specify relative priorities, which
     * is a limitation that we should take away in the base library.
     *
     * @experimental
     */
    nextSequentialRunOrder(count = 1) {
        const ret = this._nextSequentialRunOrder;
        this._nextSequentialRunOrder += count;
        return ret;
    }
    /**
     * (experimental) Whether this Stage contains an action to deploy the given stack, identified by its artifact ID.
     *
     * @experimental
     */
    deploysStack(artifactId) {
        return this.stacksToDeploy.map(s => s.stackArtifact.id).includes(artifactId);
    }
    /**
     * Actually add all the DeployStack actions to the stage.
     *
     * We do this late because before we can render the actual DeployActions,
     * we need to know whether or not we need to capture the stack outputs.
     *
     * FIXME: This is here because Actions are immutable and can't be reordered
     * after creation, nor is there a way to specify relative priorities, which
     * is a limitation that we should take away in the base library.
     */
    prepareStage() {
        // FIXME: Make sure this only gets run once. There seems to be an issue in the reconciliation
        // loop that may trigger this more than once if it throws an error somewhere, and the exception
        // that gets thrown here will then override the actual failure.
        if (this._prepared) {
            return;
        }
        this._prepared = true;
        for (const { prepareRunOrder, stackArtifact, executeRunOrder } of this.stacksToDeploy) {
            const artifact = this.host.stackOutputArtifact(stackArtifact.id);
            this.pipelineStage.addAction(actions_1.DeployCdkStackAction.fromStackArtifact(this, stackArtifact, {
                baseActionName: this.simplifyStackName(stackArtifact.stackName),
                cloudAssemblyInput: this.cloudAssemblyArtifact,
                output: artifact,
                outputFileName: artifact ? 'outputs.json' : undefined,
                prepareRunOrder,
                executeRunOrder,
            }));
        }
    }
    /**
     * Advance the runorder counter so that the next sequential number is higher than the given one
     */
    advanceRunOrderPast(lastUsed) {
        this._nextSequentialRunOrder = Math.max(lastUsed + 1, this._nextSequentialRunOrder);
    }
    /**
     * Simplify the stack name by removing the `Stage-` prefix if it exists.
     */
    simplifyStackName(s) {
        return stripPrefix(s, `${this.stageName}-`);
    }
    /**
     * Make sure all assets depended on by this stack are published in this pipeline
     *
     * Taking care to exclude the stack template itself -- it is being published
     * as an asset because the CLI needs to know the asset publishing role when
     * pushing the template to S3, but in the case of CodePipeline we always
     * reference the template from the artifact bucket.
     *
     * (NOTE: this is only true for top-level stacks, not nested stacks. Nested
     * Stack templates are always published as assets).
     */
    publishAssetDependencies(stackArtifact) {
        const assetManifests = stackArtifact.dependencies.filter(isAssetManifest);
        for (const manifestArtifact of assetManifests) {
            const manifest = asset_manifest_1.AssetManifestReader.fromFile(manifestArtifact.file);
            for (const entry of manifest.entries) {
                let assetType;
                if (entry instanceof asset_manifest_1.DockerImageManifestEntry) {
                    assetType = actions_1.AssetType.DOCKER_IMAGE;
                }
                else if (entry instanceof asset_manifest_1.FileManifestEntry) {
                    // Don't publish the template for this stack
                    if (entry.source.packaging === 'file' && entry.source.path === stackArtifact.templateFile) {
                        continue;
                    }
                    assetType = actions_1.AssetType.FILE;
                }
                else {
                    throw new Error(`Unrecognized asset type: ${entry.type}`);
                }
                if (!entry.destination.assumeRoleArn) {
                    throw new Error('assumeRoleArn is missing on asset and required');
                }
                this.host.publishAsset({
                    assetManifestPath: manifestArtifact.file,
                    assetId: entry.id.assetId,
                    assetSelector: entry.id.toString(),
                    assetType,
                    assetPublishingRoleArn: entry.destination.assumeRoleArn,
                });
            }
        }
    }
}
exports.CdkStage = CdkStage;
_a = JSII_RTTI_SYMBOL_1;
CdkStage[_a] = { fqn: "@aws-cdk/pipelines.CdkStage", version: "1.111.0" };
/**
 * (experimental) A single output of a Stack.
 *
 * @experimental
 */
class StackOutput {
    /**
     * (experimental) Build a StackOutput from a known artifact and an output name.
     *
     * @experimental
     */
    constructor(artifactFile, outputName) {
        this.artifactFile = artifactFile;
        this.outputName = outputName;
    }
}
exports.StackOutput = StackOutput;
_b = JSII_RTTI_SYMBOL_1;
StackOutput[_b] = { fqn: "@aws-cdk/pipelines.StackOutput", version: "1.111.0" };
function stripPrefix(s, prefix) {
    return s.startsWith(prefix) ? s.substr(prefix.length) : s;
}
function isAssetManifest(s) {
    // instanceof is too risky, and we're at a too late stage to properly fix.
    // return s instanceof cxapi.AssetManifestArtifact;
    return s.constructor.name === 'AssetManifestArtifact';
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RhZ2UuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJzdGFnZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUNBLCtEQUErRDtBQUMvRCx3Q0FBK0M7QUFHL0MsdUNBQTREO0FBQzVELDZEQUE0RztBQUM1RyxpREFBcUQ7QUFFckQsZ0hBQWdIO0FBQ2hILDJCQUEyQjtBQUMzQix3Q0FBMkQ7Ozs7Ozs7OztBQWtCM0QsTUFBYSxRQUFTLFNBQVEsZ0JBQWE7Ozs7SUFVekMsWUFBWSxLQUFnQixFQUFFLEVBQVUsRUFBRSxLQUFvQjtRQUM1RCxLQUFLLENBQUMsS0FBSyxFQUFFLEVBQUUsQ0FBQyxDQUFDO1FBVlgsNEJBQXVCLEdBQUcsQ0FBQyxDQUFDLENBQUMscUJBQXFCO1FBQ2xELDJCQUFzQixHQUFHLENBQUMsQ0FBQztRQUdsQixtQkFBYyxHQUFHLElBQUksS0FBSyxFQUFzQixDQUFDO1FBRzFELGNBQVMsR0FBRyxLQUFLLENBQUM7UUFLeEIsSUFBSSxDQUFDLFNBQVMsR0FBRyxLQUFLLENBQUMsU0FBUyxDQUFDO1FBQ2pDLElBQUksQ0FBQyxhQUFhLEdBQUcsS0FBSyxDQUFDLGFBQWEsQ0FBQztRQUN6QyxJQUFJLENBQUMscUJBQXFCLEdBQUcsS0FBSyxDQUFDLHFCQUFxQixDQUFDO1FBQ3pELElBQUksQ0FBQyxJQUFJLEdBQUcsS0FBSyxDQUFDLElBQUksQ0FBQztRQUV2QixjQUFPLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxFQUFFLEtBQUssRUFBRSxHQUFHLEVBQUUsQ0FBQyxJQUFJLENBQUMsWUFBWSxFQUFFLEVBQUUsQ0FBQyxDQUFDO0lBQzdELENBQUM7Ozs7Ozs7Ozs7Ozs7O0lBR00sY0FBYyxDQUFDLFFBQWUsRUFBRSxVQUEyQixFQUFFOztRQUNsRSxNQUFNLEdBQUcsR0FBRyxRQUFRLENBQUMsS0FBSyxDQUFDLEVBQUUsbUJBQW1CLEVBQUUsSUFBSSxFQUFFLENBQUMsQ0FBQztRQUMxRCxN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QVcsQ0FBQyxJQUFJLEtBQUssdUJBQXVCLENBQUM7QUFDeEQsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIGNvZGVwaXBlbGluZSBmcm9tICdAYXdzLWNkay9hd3MtY29kZXBpcGVsaW5lJztcbmltcG9ydCAqIGFzIGNwYWN0aW9ucyBmcm9tICdAYXdzLWNkay9hd3MtY29kZXBpcGVsaW5lLWFjdGlvbnMnO1xuaW1wb3J0IHsgU3RhZ2UsIEFzcGVjdHMgfSBmcm9tICdAYXdzLWNkay9jb3JlJztcbmltcG9ydCAqIGFzIGN4YXBpIGZyb20gJ0Bhd3MtY2RrL2N4LWFwaSc7XG5pbXBvcnQgeyBDb25zdHJ1Y3QgfSBmcm9tICdjb25zdHJ1Y3RzJztcbmltcG9ydCB7IEFzc2V0VHlwZSwgRGVwbG95Q2RrU3RhY2tBY3Rpb24gfSBmcm9tICcuL2FjdGlvbnMnO1xuaW1wb3J0IHsgQXNzZXRNYW5pZmVzdFJlYWRlciwgRG9ja2VySW1hZ2VNYW5pZmVzdEVudHJ5LCBGaWxlTWFuaWZlc3RFbnRyeSB9IGZyb20gJy4vcHJpdmF0ZS9hc3NldC1tYW5pZmVzdCc7XG5pbXBvcnQgeyB0b3BvbG9naWNhbFNvcnQgfSBmcm9tICcuL3ByaXZhdGUvdG9wb3NvcnQnO1xuXG4vLyB2MiAtIGtlZXAgdGhpcyBpbXBvcnQgYXMgYSBzZXBhcmF0ZSBzZWN0aW9uIHRvIHJlZHVjZSBtZXJnZSBjb25mbGljdCB3aGVuIGZvcndhcmQgbWVyZ2luZyB3aXRoIHRoZSB2MiBicmFuY2guXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbmltcG9ydCB7IENvbnN0cnVjdCBhcyBDb3JlQ29uc3RydWN0IH0gZnJvbSAnQGF3cy1jZGsvY29yZSc7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbmV4cG9ydCBpbnRlcmZhY2UgQ2RrU3RhZ2VQcm9wcyB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgcmVhZG9ubHkgc3RhZ2VOYW1lOiBzdHJpbmc7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICByZWFkb25seSBwaXBlbGluZVN0YWdlOiBjb2RlcGlwZWxpbmUuSVN0YWdlO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgcmVhZG9ubHkgY2xvdWRBc3NlbWJseUFydGlmYWN0OiBjb2RlcGlwZWxpbmUuQXJ0aWZhY3Q7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gIHJlYWRvbmx5IGhvc3Q6IElTdGFnZUhvc3Q7XG59XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG5leHBvcnQgY2xhc3MgQ2RrU3RhZ2UgZXh0ZW5kcyBDb3JlQ29uc3RydWN0IHtcbiAgcHJpdmF0ZSBfbmV4dFNlcXVlbnRpYWxSdW5PcmRlciA9IDE7IC8vIE11c3Qgc3RhcnQgYXQgMSBlaFxuICBwcml2YXRlIF9tYW51YWxBcHByb3ZhbENvdW50ZXIgPSAxO1xuICBwcml2YXRlIHJlYWRvbmx5IHBpcGVsaW5lU3RhZ2U6IGNvZGVwaXBlbGluZS5JU3RhZ2U7XG4gIHByaXZhdGUgcmVhZG9ubHkgY2xvdWRBc3NlbWJseUFydGlmYWN0OiBjb2RlcGlwZWxpbmUuQXJ0aWZhY3Q7XG4gIHByaXZhdGUgcmVhZG9ubHkgc3RhY2tzVG9EZXBsb3kgPSBuZXcgQXJyYXk8RGVwbG95U3RhY2tDb21tYW5kPigpO1xuICBwcml2YXRlIHJlYWRvbmx5IHN0YWdlTmFtZTogc3RyaW5nO1xuICBwcml2YXRlIHJlYWRvbmx5IGhvc3Q6IElTdGFnZUhvc3Q7XG4gIHByaXZhdGUgX3ByZXBhcmVkID0gZmFsc2U7XG5cbiAgY29uc3RydWN0b3Ioc2NvcGU6IENvbnN0cnVjdCwgaWQ6IHN0cmluZywgcHJvcHM6IENka1N0YWdlUHJvcHMpIHtcbiAgICBzdXBlcihzY29wZSwgaWQpO1xuXG4gICAgdGhpcy5zdGFnZU5hbWUgPSBwcm9wcy5zdGFnZU5hbWU7XG4gICAgdGhpcy5waXBlbGluZVN0YWdlID0gcHJvcHMucGlwZWxpbmVTdGFnZTtcbiAgICB0aGlzLmNsb3VkQXNzZW1ibHlBcnRpZmFjdCA9IHByb3BzLmNsb3VkQXNzZW1ibHlBcnRpZmFjdDtcbiAgICB0aGlzLmhvc3QgPSBwcm9wcy5ob3N0O1xuXG4gICAgQXNwZWN0cy5vZih0aGlzKS5hZGQoeyB2aXNpdDogKCkgPT4gdGhpcy5wcmVwYXJlU3RhZ2UoKSB9KTtcbiAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICBwdWJsaWMgYWRkQXBwbGljYXRpb24oYXBwU3RhZ2U6IFN0YWdlLCBvcHRpb25zOiBBZGRTdGFnZU9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IGFzbSA9IGFwcFN0YWdlLnN5bnRoKHsgdmFsaWRhdGVPblN5bnRoZXNpczogdHJ1ZSB9KTtcbiAgICBjb25zdCBleHRyYVJ1bk9yZGVyU3BhY2UgPSBvcHRpb25zLmV4dHJhUnVuT3JkZXJTcGFjZSA/PyAwO1xuXG4gICAgaWYgKGFzbS5zdGFja3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAvLyBJZiB3ZSBkb24ndCBjaGVjayBoZXJlLCBhIG1vcmUgcHV6emxpbmcgXCJzdGFnZSBjb250YWlucyBubyBhY3Rpb25zXCJcbiAgICAgIC8vIGVycm9yIHdpbGwgYmUgdGhyb3duIGNvbWUgZGVwbG95bWVudCB0aW1lLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgZ2l2ZW4gU3RhZ2UgY29uc3RydWN0ICgnJHthcHBTdGFnZS5ub2RlLnBhdGh9Jykgc2hvdWxkIGNvbnRhaW4gYXQgbGVhc3Qgb25lIFN0YWNrYCk7XG4gICAgfVxuXG4gICAgY29uc3Qgc29ydGVkVHJhbmNoZXMgPSB0b3BvbG9naWNhbFNvcnQoYXNtLnN0YWNrcyxcbiAgICAgIHN0YWNrID0+IHN0YWNrLmlkLFxuICAgICAgc3RhY2sgPT4gc3RhY2suZGVwZW5kZW5jaWVzLm1hcChkID0+IGQuaWQpKTtcblxuICAgIGZvciAoY29uc3Qgc3RhY2tzIG9mIHNvcnRlZFRyYW5jaGVzKSB7XG4gICAgICBjb25zdCBydW5PcmRlciA9IHRoaXMubmV4dFNlcXVlbnRpYWxSdW5PcmRlcihleHRyYVJ1bk9yZGVyU3BhY2UgKyAyKTsgLy8gMiBhY3Rpb25zIGZvciBQcmVwYXJlL0V4ZWN1dGUgQ2hhbmdlU2V0XG4gICAgICBsZXQgZXhlY3V0ZVJ1bk9yZGVyID0gcnVuT3JkZXIgKyBleHRyYVJ1bk9yZGVyU3BhY2UgKyAxO1xuXG4gICAgICAvLyBJZiB3ZSBuZWVkIHRvIGluc2VydCBhIG1hbnVhbCBhcHByb3ZhbCBhY3Rpb24sIHRoZW4gd2hhdCdzIHRoZSBleGVjdXRlUnVuT3JkZXJcbiAgICAgIC8vIG5vdyBpcyB3aGVyZSB3ZSBhZGQgYSBtYW51YWwgYXBwcm92YWwgc3RlcCwgYW5kIHdlIGFsbG9jYXRlIDEgbW9yZSBydW5PcmRlclxuICAgICAgLy8gZm9yIHRoZSBleGVjdXRlLlxuICAgICAgaWYgKG9wdGlvbnMubWFudWFsQXBwcm92YWxzKSB7XG4gICAgICAgIHRoaXMuYWRkTWFudWFsQXBwcm92YWxBY3Rpb24oeyBydW5PcmRlcjogcnVuT3JkZXIgKyAxIH0pO1xuICAgICAgICBleGVjdXRlUnVuT3JkZXIgPSB0aGlzLm5leHRTZXF1ZW50aWFsUnVuT3JkZXIoKTtcbiAgICAgIH1cblxuICAgICAgLy8gVGhlc2UgZG9uJ3QgaGF2ZSBhIGRlcGVuZGVuY3kgb24gZWFjaCBvdGhlciwgc28gY2FuIGFsbCBiZSBhZGRlZCBpbiBwYXJhbGxlbFxuICAgICAgZm9yIChjb25zdCBzdGFjayBvZiBzdGFja3MpIHtcbiAgICAgICAgdGhpcy5hZGRTdGFja0FydGlmYWN0RGVwbG95bWVudChzdGFjaywgeyBydW5PcmRlciwgZXhlY3V0ZVJ1bk9yZGVyIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgcHVibGljIGFkZFN0YWNrQXJ0aWZhY3REZXBsb3ltZW50KHN0YWNrQXJ0aWZhY3Q6IGN4YXBpLkNsb3VkRm9ybWF0aW9uU3RhY2tBcnRpZmFjdCwgb3B0aW9uczogQWRkU3RhY2tPcHRpb25zID0ge30pIHtcbiAgICAvLyBHZXQgYWxsIGFzc2V0cyBtYW5pZmVzdHMgYW5kIGFkZCB0aGUgYXNzZXRzIGluICdlbSB0byB0aGUgYXNzZXQgcHVibGlzaGluZyBzdGFnZS5cbiAgICB0aGlzLnB1Ymxpc2hBc3NldERlcGVuZGVuY2llcyhzdGFja0FydGlmYWN0KTtcblxuICAgIC8vIFJlbWVtYmVyIGZvciBsYXRlciwgc2VlICdwcmVwYXJlKCknXG4gICAgLy8gV2Uga25vdyB0aGF0IGRlcGxveWluZyBhIHN0YWNrIGlzIGdvaW5nIHRvIHRha2UgdXAgMiBydW5vcmRlciBzbG90cyBsYXRlciBvbi5cbiAgICBjb25zdCBydW5PcmRlciA9IG9wdGlvbnMucnVuT3JkZXIgPz8gdGhpcy5uZXh0U2VxdWVudGlhbFJ1bk9yZGVyKDIpO1xuICAgIGNvbnN0IGV4ZWN1dGVSdW5PcmRlciA9IG9wdGlvbnMuZXhlY3V0ZVJ1bk9yZGVyID8/IHJ1bk9yZGVyICsgMTtcbiAgICB0aGlzLnN0YWNrc1RvRGVwbG95LnB1c2goe1xuICAgICAgcHJlcGFyZVJ1bk9yZGVyOiBydW5PcmRlcixcbiAgICAgIGV4ZWN1dGVSdW5PcmRlcixcbiAgICAgIHN0YWNrQXJ0aWZhY3QsXG4gICAgfSk7XG5cbiAgICB0aGlzLmFkdmFuY2VSdW5PcmRlclBhc3QocnVuT3JkZXIpO1xuICAgIHRoaXMuYWR2YW5jZVJ1bk9yZGVyUGFzdChleGVjdXRlUnVuT3JkZXIpO1xuICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgcHVibGljIGFkZE1hbnVhbEFwcHJvdmFsQWN0aW9uKG9wdGlvbnM6IEFkZE1hbnVhbEFwcHJvdmFsT3B0aW9ucyA9IHt9KSB7XG4gICAgbGV0IGFjdGlvbk5hbWUgPSBvcHRpb25zLmFjdGlvbk5hbWU7XG4gICAgaWYgKCFhY3Rpb25OYW1lKSB7XG4gICAgICBhY3Rpb25OYW1lID0gYE1hbnVhbEFwcHJvdmFsJHt0aGlzLl9tYW51YWxBcHByb3ZhbENvdW50ZXIgPiAxID8gdGhpcy5fbWFudWFsQXBwcm92YWxDb3VudGVyIDogJyd9YDtcbiAgICAgIHRoaXMuX21hbnVhbEFwcHJvdmFsQ291bnRlciArPSAxO1xuICAgIH1cblxuICAgIHRoaXMuYWRkQWN0aW9ucyhuZXcgY3BhY3Rpb25zLk1hbnVhbEFwcHJvdmFsQWN0aW9uKHtcbiAgICAgIGFjdGlvbk5hbWUsXG4gICAgICBydW5PcmRlcjogb3B0aW9ucy5ydW5PcmRlciA/PyB0aGlzLm5leHRTZXF1ZW50aWFsUnVuT3JkZXIoKSxcbiAgICB9KSk7XG4gIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICBwdWJsaWMgYWRkQWN0aW9ucyguLi5hY3Rpb25zOiBjb2RlcGlwZWxpbmUuSUFjdGlvbltdKSB7XG4gICAgZm9yIChjb25zdCBhY3Rpb24gb2YgYWN0aW9ucykge1xuICAgICAgdGhpcy5waXBlbGluZVN0YWdlLmFkZEFjdGlvbihhY3Rpb24pO1xuICAgIH1cbiAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgcHVibGljIG5leHRTZXF1ZW50aWFsUnVuT3JkZXIoY291bnQ6IG51bWJlciA9IDEpOiBudW1iZXIge1xuICAgIGNvbnN0IHJldCA9IHRoaXMuX25leHRTZXF1ZW50aWFsUnVuT3JkZXI7XG4gICAgdGhpcy5fbmV4dFNlcXVlbnRpYWxSdW5PcmRlciArPSBjb3VudDtcbiAgICByZXR1cm4gcmV0O1xuICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICBwdWJsaWMgZGVwbG95c1N0YWNrKGFydGlmYWN0SWQ6IHN0cmluZykge1xuICAgIHJldHVybiB0aGlzLnN0YWNrc1RvRGVwbG95Lm1hcChzID0+IHMuc3RhY2tBcnRpZmFjdC5pZCkuaW5jbHVkZXMoYXJ0aWZhY3RJZCk7XG4gIH1cblxuICAvKipcbiAgICogQWN0dWFsbHkgYWRkIGFsbCB0aGUgRGVwbG95U3RhY2sgYWN0aW9ucyB0byB0aGUgc3RhZ2UuXG4gICAqXG4gICAqIFdlIGRvIHRoaXMgbGF0ZSBiZWNhdXNlIGJlZm9yZSB3ZSBjYW4gcmVuZGVyIHRoZSBhY3R1YWwgRGVwbG95QWN0aW9ucyxcbiAgICogd2UgbmVlZCB0byBrbm93IHdoZXRoZXIgb3Igbm90IHdlIG5lZWQgdG8gY2FwdHVyZSB0aGUgc3RhY2sgb3V0cHV0cy5cbiAgICpcbiAgICogRklYTUU6IFRoaXMgaXMgaGVyZSBiZWNhdXNlIEFjdGlvbnMgYXJlIGltbXV0YWJsZSBhbmQgY2FuJ3QgYmUgcmVvcmRlcmVkXG4gICAqIGFmdGVyIGNyZWF0aW9uLCBub3IgaXMgdGhlcmUgYSB3YXkgdG8gc3BlY2lmeSByZWxhdGl2ZSBwcmlvcml0aWVzLCB3aGljaFxuICAgKiBpcyBhIGxpbWl0YXRpb24gdGhhdCB3ZSBzaG91bGQgdGFrZSBhd2F5IGluIHRoZSBiYXNlIGxpYnJhcnkuXG4gICAqL1xuICBwcml2YXRlIHByZXBhcmVTdGFnZSgpIHtcbiAgICAvLyBGSVhNRTogTWFrZSBzdXJlIHRoaXMgb25seSBnZXRzIHJ1biBvbmNlLiBUaGVyZSBzZWVtcyB0byBiZSBhbiBpc3N1ZSBpbiB0aGUgcmVjb25jaWxpYXRpb25cbiAgICAvLyBsb29wIHRoYXQgbWF5IHRyaWdnZXIgdGhpcyBtb3JlIHRoYW4gb25jZSBpZiBpdCB0aHJvd3MgYW4gZXJyb3Igc29tZXdoZXJlLCBhbmQgdGhlIGV4Y2VwdGlvblxuICAgIC8vIHRoYXQgZ2V0cyB0aHJvd24gaGVyZSB3aWxsIHRoZW4gb3ZlcnJpZGUgdGhlIGFjdHVhbCBmYWlsdXJlLlxuICAgIGlmICh0aGlzLl9wcmVwYXJlZCkgeyByZXR1cm47IH1cbiAgICB0aGlzLl9wcmVwYXJlZCA9IHRydWU7XG5cbiAgICBmb3IgKGNvbnN0IHsgcHJlcGFyZVJ1bk9yZGVyLCBzdGFja0FydGlmYWN0LCBleGVjdXRlUnVuT3JkZXIgfSBvZiB0aGlzLnN0YWNrc1RvRGVwbG95KSB7XG4gICAgICBjb25zdCBhcnRpZmFjdCA9IHRoaXMuaG9zdC5zdGFja091dHB1dEFydGlmYWN0KHN0YWNrQXJ0aWZhY3QuaWQpO1xuXG4gICAgICB0aGlzLnBpcGVsaW5lU3RhZ2UuYWRkQWN0aW9uKERlcGxveUNka1N0YWNrQWN0aW9uLmZyb21TdGFja0FydGlmYWN0KHRoaXMsIHN0YWNrQXJ0aWZhY3QsIHtcbiAgICAgICAgYmFzZUFjdGlvbk5hbWU6IHRoaXMuc2ltcGxpZnlTdGFja05hbWUoc3RhY2tBcnRpZmFjdC5zdGFja05hbWUpLFxuICAgICAgICBjbG91ZEFzc2VtYmx5SW5wdXQ6IHRoaXMuY2xvdWRBc3NlbWJseUFydGlmYWN0LFxuICAgICAgICBvdXRwdXQ6IGFydGlmYWN0LFxuICAgICAgICBvdXRwdXRGaWxlTmFtZTogYXJ0aWZhY3QgPyAnb3V0cHV0cy5qc29uJyA6IHVuZGVmaW5lZCxcbiAgICAgICAgcHJlcGFyZVJ1bk9yZGVyLFxuICAgICAgICBleGVjdXRlUnVuT3JkZXIsXG4gICAgICB9KSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEFkdmFuY2UgdGhlIHJ1bm9yZGVyIGNvdW50ZXIgc28gdGhhdCB0aGUgbmV4dCBzZXF1ZW50aWFsIG51bWJlciBpcyBoaWdoZXIgdGhhbiB0aGUgZ2l2ZW4gb25lXG4gICAqL1xuICBwcml2YXRlIGFkdmFuY2VSdW5PcmRlclBhc3QobGFzdFVzZWQ6IG51bWJlcikge1xuICAgIHRoaXMuX25leHRTZXF1ZW50aWFsUnVuT3JkZXIgPSBNYXRoLm1heChsYXN0VXNlZCArIDEsIHRoaXMuX25leHRTZXF1ZW50aWFsUnVuT3JkZXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNpbXBsaWZ5IHRoZSBzdGFjayBuYW1lIGJ5IHJlbW92aW5nIHRoZSBgU3RhZ2UtYCBwcmVmaXggaWYgaXQgZXhpc3RzLlxuICAgKi9cbiAgcHJpdmF0ZSBzaW1wbGlmeVN0YWNrTmFtZShzOiBzdHJpbmcpIHtcbiAgICByZXR1cm4gc3RyaXBQcmVmaXgocywgYCR7dGhpcy5zdGFnZU5hbWV9LWApO1xuICB9XG5cbiAgLyoqXG4gICAqIE1ha2Ugc3VyZSBhbGwgYXNzZXRzIGRlcGVuZGVkIG9uIGJ5IHRoaXMgc3RhY2sgYXJlIHB1Ymxpc2hlZCBpbiB0aGlzIHBpcGVsaW5lXG4gICAqXG4gICAqIFRha2luZyBjYXJlIHRvIGV4Y2x1ZGUgdGhlIHN0YWNrIHRlbXBsYXRlIGl0c2VsZiAtLSBpdCBpcyBiZWluZyBwdWJsaXNoZWRcbiAgICogYXMgYW4gYXNzZXQgYmVjYXVzZSB0aGUgQ0xJIG5lZWRzIHRvIGtub3cgdGhlIGFzc2V0IHB1Ymxpc2hpbmcgcm9sZSB3aGVuXG4gICAqIHB1c2hpbmcgdGhlIHRlbXBsYXRlIHRvIFMzLCBidXQgaW4gdGhlIGNhc2Ugb2YgQ29kZVBpcGVsaW5lIHdlIGFsd2F5c1xuICAgKiByZWZlcmVuY2UgdGhlIHRlbXBsYXRlIGZyb20gdGhlIGFydGlmYWN0IGJ1Y2tldC5cbiAgICpcbiAgICogKE5PVEU6IHRoaXMgaXMgb25seSB0cnVlIGZvciB0b3AtbGV2ZWwgc3RhY2tzLCBub3QgbmVzdGVkIHN0YWNrcy4gTmVzdGVkXG4gICAqIFN0YWNrIHRlbXBsYXRlcyBhcmUgYWx3YXlzIHB1Ymxpc2hlZCBhcyBhc3NldHMpLlxuICAgKi9cbiAgcHJpdmF0ZSBwdWJsaXNoQXNzZXREZXBlbmRlbmNpZXMoc3RhY2tBcnRpZmFjdDogY3hhcGkuQ2xvdWRGb3JtYXRpb25TdGFja0FydGlmYWN0KSB7XG4gICAgY29uc3QgYXNzZXRNYW5pZmVzdHMgPSBzdGFja0FydGlmYWN0LmRlcGVuZGVuY2llcy5maWx0ZXIoaXNBc3NldE1hbmlmZXN0KTtcblxuICAgIGZvciAoY29uc3QgbWFuaWZlc3RBcnRpZmFjdCBvZiBhc3NldE1hbmlmZXN0cykge1xuICAgICAgY29uc3QgbWFuaWZlc3QgPSBBc3NldE1hbmlmZXN0UmVhZGVyLmZyb21GaWxlKG1hbmlmZXN0QXJ0aWZhY3QuZmlsZSk7XG5cbiAgICAgIGZvciAoY29uc3QgZW50cnkgb2YgbWFuaWZlc3QuZW50cmllcykge1xuICAgICAgICBsZXQgYXNzZXRUeXBlOiBBc3NldFR5cGU7XG4gICAgICAgIGlmIChlbnRyeSBpbnN0YW5jZW9mIERvY2tlckltYWdlTWFuaWZlc3RFbnRyeSkge1xuICAgICAgICAgIGFzc2V0VHlwZSA9IEFzc2V0VHlwZS5ET0NLRVJfSU1BR0U7XG4gICAgICAgIH0gZWxzZSBpZiAoZW50cnkgaW5zdGFuY2VvZiBGaWxlTWFuaWZlc3RFbnRyeSkge1xuICAgICAgICAgIC8vIERvbid0IHB1Ymxpc2ggdGhlIHRlbXBsYXRlIGZvciB0aGlzIHN0YWNrXG4gICAgICAgICAgaWYgKGVudHJ5LnNvdXJjZS5wYWNrYWdpbmcgPT09ICdmaWxlJyAmJiBlbnRyeS5zb3VyY2UucGF0aCA9PT0gc3RhY2tBcnRpZmFjdC50ZW1wbGF0ZUZpbGUpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGFzc2V0VHlwZSA9IEFzc2V0VHlwZS5GSUxFO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5yZWNvZ25pemVkIGFzc2V0IHR5cGU6ICR7ZW50cnkudHlwZX1gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghZW50cnkuZGVzdGluYXRpb24uYXNzdW1lUm9sZUFybikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYXNzdW1lUm9sZUFybiBpcyBtaXNzaW5nIG9uIGFzc2V0IGFuZCByZXF1aXJlZCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5ob3N0LnB1Ymxpc2hBc3NldCh7XG4gICAgICAgICAgYXNzZXRNYW5pZmVzdFBhdGg6IG1hbmlmZXN0QXJ0aWZhY3QuZmlsZSxcbiAgICAgICAgICBhc3NldElkOiBlbnRyeS5pZC5hc3NldElkLFxuICAgICAgICAgIGFzc2V0U2VsZWN0b3I6IGVudHJ5LmlkLnRvU3RyaW5nKCksXG4gICAgICAgICAgYXNzZXRUeXBlLFxuICAgICAgICAgIGFzc2V0UHVibGlzaGluZ1JvbGVBcm46IGVudHJ5LmRlc3RpbmF0aW9uLmFzc3VtZVJvbGVBcm4sXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuZXhwb3J0IGludGVyZmFjZSBBZGRTdGFja09wdGlvbnMge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICByZWFkb25seSBydW5PcmRlcj86IG51bWJlcjtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICByZWFkb25seSBleGVjdXRlUnVuT3JkZXI/OiBudW1iZXI7XG59XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbmV4cG9ydCBjbGFzcyBTdGFja091dHB1dCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICBwdWJsaWMgcmVhZG9ubHkgYXJ0aWZhY3RGaWxlOiBjb2RlcGlwZWxpbmUuQXJ0aWZhY3RQYXRoO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gIHB1YmxpYyByZWFkb25seSBvdXRwdXROYW1lOiBzdHJpbmc7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gIGNvbnN0cnVjdG9yKGFydGlmYWN0RmlsZTogY29kZXBpcGVsaW5lLkFydGlmYWN0UGF0aCwgb3V0cHV0TmFtZTogc3RyaW5nKSB7XG4gICAgdGhpcy5hcnRpZmFjdEZpbGUgPSBhcnRpZmFjdEZpbGU7XG4gICAgdGhpcy5vdXRwdXROYW1lID0gb3V0cHV0TmFtZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzdHJpcFByZWZpeChzOiBzdHJpbmcsIHByZWZpeDogc3RyaW5nKSB7XG4gIHJldHVybiBzLnN0YXJ0c1dpdGgocHJlZml4KSA/IHMuc3Vic3RyKHByZWZpeC5sZW5ndGgpIDogcztcbn1cblxuZnVuY3Rpb24gaXNBc3NldE1hbmlmZXN0KHM6IGN4YXBpLkNsb3VkQXJ0aWZhY3QpOiBzIGlzIGN4YXBpLkFzc2V0TWFuaWZlc3RBcnRpZmFjdCB7XG4gIC8vIGluc3RhbmNlb2YgaXMgdG9vIHJpc2t5LCBhbmQgd2UncmUgYXQgYSB0b28gbGF0ZSBzdGFnZSB0byBwcm9wZXJseSBmaXguXG4gIC8vIHJldHVybiBzIGluc3RhbmNlb2YgY3hhcGkuQXNzZXRNYW5pZmVzdEFydGlmYWN0O1xuICByZXR1cm4gcy5jb25zdHJ1Y3Rvci5uYW1lID09PSAnQXNzZXRNYW5pZmVzdEFydGlmYWN0Jztcbn1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuZXhwb3J0IGludGVyZmFjZSBJU3RhZ2VIb3N0IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgcHVibGlzaEFzc2V0KGNvbW1hbmQ6IEFzc2V0UHVibGlzaGluZ0NvbW1hbmQpOiB2b2lkO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICBzdGFja091dHB1dEFydGlmYWN0KHN0YWNrQXJ0aWZhY3RJZDogc3RyaW5nKTogY29kZXBpcGVsaW5lLkFydGlmYWN0IHwgdW5kZWZpbmVkO1xufVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG5leHBvcnQgaW50ZXJmYWNlIEFzc2V0UHVibGlzaGluZ0NvbW1hbmQge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gIHJlYWRvbmx5IGFzc2V0TWFuaWZlc3RQYXRoOiBzdHJpbmc7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICByZWFkb25seSBhc3NldElkOiBzdHJpbmc7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gIHJlYWRvbmx5IGFzc2V0U2VsZWN0b3I6IHN0cmluZztcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgcmVhZG9ubHkgYXNzZXRUeXBlOiBBc3NldFR5cGU7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgcmVhZG9ubHkgYXNzZXRQdWJsaXNoaW5nUm9sZUFybjogc3RyaW5nO1xufVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG5leHBvcnQgaW50ZXJmYWNlIEFkZFN0YWdlT3B0aW9ucyB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgcmVhZG9ubHkgbWFudWFsQXBwcm92YWxzPzogYm9vbGVhbjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgcmVhZG9ubHkgZXh0cmFSdW5PcmRlclNwYWNlPzogbnVtYmVyO1xufVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG5leHBvcnQgaW50ZXJmYWNlIEFkZE1hbnVhbEFwcHJvdmFsT3B0aW9ucyB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgcmVhZG9ubHkgYWN0aW9uTmFtZT86IHN0cmluZztcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgcmVhZG9ubHkgcnVuT3JkZXI/OiBudW1iZXI7XG59XG5cbi8qKlxuICogUXVldWVkIFwiZGVwbG95IHN0YWNrXCIgY29tbWFuZCB0aGF0IGlzIHJlaWZpZWQgZHVyaW5nIHByZXBhcmUoKVxuICovXG5pbnRlcmZhY2UgRGVwbG95U3RhY2tDb21tYW5kIHtcbiAgcHJlcGFyZVJ1bk9yZGVyOiBudW1iZXI7XG4gIGV4ZWN1dGVSdW5PcmRlcjogbnVtYmVyO1xuICBzdGFja0FydGlmYWN0OiBjeGFwaS5DbG91ZEZvcm1hdGlvblN0YWNrQXJ0aWZhY3Q7XG59XG4iXX0=