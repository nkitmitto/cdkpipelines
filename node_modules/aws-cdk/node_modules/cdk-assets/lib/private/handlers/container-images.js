"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ContainerImageAssetHandler = void 0;
const path = require("path");
const progress_1 = require("../../progress");
const docker_1 = require("../docker");
const placeholders_1 = require("../placeholders");
const shell_1 = require("../shell");
class ContainerImageAssetHandler {
    constructor(workDir, asset, host) {
        this.workDir = workDir;
        this.asset = asset;
        this.host = host;
        this.docker = new docker_1.Docker(m => this.host.emitMessage(progress_1.EventType.DEBUG, m));
    }
    async publish() {
        const destination = await placeholders_1.replaceAwsPlaceholders(this.asset.destination, this.host.aws);
        const ecr = await this.host.aws.ecrClient(destination);
        const account = async () => { var _a; return (_a = (await this.host.aws.discoverCurrentAccount())) === null || _a === void 0 ? void 0 : _a.accountId; };
        const repoUri = await repositoryUri(ecr, destination.repositoryName);
        if (!repoUri) {
            throw new Error(`No ECR repository named '${destination.repositoryName}' in account ${await account()}. Is this account bootstrapped?`);
        }
        const imageUri = `${repoUri}:${destination.imageTag}`;
        if (await this.destinationAlreadyExists(ecr, destination, imageUri)) {
            return;
        }
        if (this.host.aborted) {
            return;
        }
        // Login before build so that the Dockerfile can reference images in the ECR repo
        await this.docker.login(ecr);
        const localTagName = this.asset.source.executable
            ? await this.buildExternalAsset(this.asset.source.executable)
            : await this.buildDirectoryAsset();
        if (localTagName === undefined || this.host.aborted) {
            return;
        }
        this.host.emitMessage(progress_1.EventType.UPLOAD, `Push ${imageUri}`);
        if (this.host.aborted) {
            return;
        }
        await this.docker.tag(localTagName, imageUri);
        await this.docker.push(imageUri);
    }
    /**
     * Build a (local) Docker asset from a directory with a Dockerfile
     *
     * Tags under a deterministic, unique, local identifier wich will skip
     * the build if it already exists.
     */
    async buildDirectoryAsset() {
        const localTagName = `cdkasset-${this.asset.id.assetId.toLowerCase()}`;
        if (!(await this.isImageCached(localTagName))) {
            if (this.host.aborted) {
                return undefined;
            }
            await this.buildImage(localTagName);
        }
        return localTagName;
    }
    /**
     * Build a (local) Docker asset by running an external command
     *
     * External command is responsible for deduplicating the build if possible,
     * and is expected to return the generated image identifier on stdout.
     */
    async buildExternalAsset(executable) {
        this.host.emitMessage(progress_1.EventType.BUILD, `Building Docker image using command '${executable}'`);
        if (this.host.aborted) {
            return undefined;
        }
        return (await shell_1.shell(executable, { quiet: true })).trim();
    }
    /**
     * Check whether the image already exists in the ECR repo
     *
     * Use the fields from the destination to do the actual check. The imageUri
     * should correspond to that, but is only used to print Docker image location
     * for user benefit (the format is slightly different).
     */
    async destinationAlreadyExists(ecr, destination, imageUri) {
        this.host.emitMessage(progress_1.EventType.CHECK, `Check ${imageUri}`);
        if (await imageExists(ecr, destination.repositoryName, destination.imageTag)) {
            this.host.emitMessage(progress_1.EventType.FOUND, `Found ${imageUri}`);
            return true;
        }
        return false;
    }
    async buildImage(localTagName) {
        const source = this.asset.source;
        if (!source.directory) {
            throw new Error(`'directory' is expected in the DockerImage asset source, got: ${JSON.stringify(source)}`);
        }
        const fullPath = path.resolve(this.workDir, source.directory);
        this.host.emitMessage(progress_1.EventType.BUILD, `Building Docker image at ${fullPath}`);
        await this.docker.build({
            directory: fullPath,
            tag: localTagName,
            buildArgs: source.dockerBuildArgs,
            target: source.dockerBuildTarget,
            file: source.dockerFile,
        });
    }
    async isImageCached(localTagName) {
        if (await this.docker.exists(localTagName)) {
            this.host.emitMessage(progress_1.EventType.CACHED, `Cached ${localTagName}`);
            return true;
        }
        return false;
    }
}
exports.ContainerImageAssetHandler = ContainerImageAssetHandler;
async function imageExists(ecr, repositoryName, imageTag) {
    try {
        await ecr.describeImages({ repositoryName, imageIds: [{ imageTag }] }).promise();
        return true;
    }
    catch (e) {
        if (e.code !== 'ImageNotFoundException') {
            throw e;
        }
        return false;
    }
}
/**
 * Return the URI for the repository with the given name
 *
 * Returns undefined if the repository does not exist.
 */
async function repositoryUri(ecr, repositoryName) {
    var _a;
    try {
        const response = await ecr.describeRepositories({ repositoryNames: [repositoryName] }).promise();
        return (_a = (response.repositories || [])[0]) === null || _a === void 0 ? void 0 : _a.repositoryUri;
    }
    catch (e) {
        if (e.code !== 'RepositoryNotFoundException') {
            throw e;
        }
        return undefined;
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29udGFpbmVyLWltYWdlcy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvbnRhaW5lci1pbWFnZXMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQUEsNkJBQTZCO0FBRzdCLDZDQUEyQztBQUUzQyxzQ0FBbUM7QUFDbkMsa0RBQXlEO0FBQ3pELG9DQUFpQztBQUVqQyxNQUFhLDBCQUEwQjtJQUdyQyxZQUNtQixPQUFlLEVBQ2YsS0FBK0IsRUFDL0IsSUFBa0I7UUFGbEIsWUFBTyxHQUFQLE9BQU8sQ0FBUTtRQUNmLFVBQUssR0FBTCxLQUFLLENBQTBCO1FBQy9CLFNBQUksR0FBSixJQUFJLENBQWM7UUFMcEIsV0FBTSxHQUFHLElBQUksZUFBTSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsb0JBQVMsQ0FBQyxLQUFLLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQU1yRixDQUFDO0lBRU0sS0FBSyxDQUFDLE9BQU87UUFDbEIsTUFBTSxXQUFXLEdBQUcsTUFBTSxxQ0FBc0IsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLFdBQVcsRUFBRSxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQ3hGLE1BQU0sR0FBRyxHQUFHLE1BQU0sSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsU0FBUyxDQUFDLFdBQVcsQ0FBQyxDQUFDO1FBQ3ZELE1BQU0sT0FBTyxHQUFHLEtBQUssSUFBSSxFQUFFLHdCQUFDLENBQUMsTUFBTSxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxzQkFBc0IsRUFBRSxDQUFDLDBDQUFFLFNBQVMsR0FBQSxDQUFDO1FBQ3RGLE1BQU0sT0FBTyxHQUFHLE1BQU0sYUFBYSxDQUFDLEdBQUcsRUFBRSxXQUFXLENBQUMsY0FBYyxDQUFDLENBQUM7UUFFckUsSUFBSSxDQUFDLE9BQU8sRUFBRTtZQUNaLE1BQU0sSUFBSSxLQUFLLENBQUMsNEJB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RUFvSEM7QUFFRCxLQUFLLFVBQVUsV0FBVyxDQUFDLEdBQVksRUFBRSxjQUFzQixFQUFFLFFBQWdCO0lBQy9FLElBQUk7UUFDRixNQUFNLEdBQUcsQ0FBQyxjQUFjLENBQUMsRUFBRSxjQUFjLEVBQUUsUUFBUSxFQUFFLENBQUMsRUFBRSxRQUFRLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxPQUFPLEVBQUUsQ0FBQztRQUNqRixPQUFPLElBQUksQ0FBQztLQUNiO0lBQUMsT0FBTyxDQUFDLEVBQUU7UUFDVixJQUFJLENBQUMsQ0FBQyxJQUFJLEtBQUssd0JBQXdCLEVBQUU7WUFBRSxNQUFNLENBQUMsQ0FBQztTQUFFO1FBQ3JELE9BQU8sS0FBSyxDQUFDO0tBQ2Q7QUFDSCxDQUFDO0FBRUQ7Ozs7R0FJRztBQUNILEtBQUssVUFBVSxhQUFhLENBQUMsR0FBWSxFQUFFLGNBQXNCOztJQUMvRCxJQUFJO1FBQ0YsTUFBTSxRQUFRLEdBQUcsTUFBTSxHQUFHLENBQUMsb0JBQW9CLENBQUMsRUFBRSxlQUFlLEVBQUUsQ0FBQyxjQUFjLENBQUMsRUFBRSxDQUFDLENBQUMsT0FBTyxFQUFFLENBQUM7UUFDakcsYUFBTyxDQUFDLFFBQVEsQ0FBQyxZQUFZLElBQUksRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLDBDQUFFLGFBQWEsQ0FBQztLQUN4RDtJQUFDLE9BQU8sQ0FBQyxFQUFFO1FBQ1YsSUFBSSxDQUFDLENBQUMsSUFBSSxLQUFLLDZCQUE2QixFQUFFO1lBQUUsTUFBTSxDQUFDLENBQUM7U0FBRTtRQUMxRCxPQUFPLFNBQVMsQ0FBQztLQUNsQjtBQUNILENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBwYXRoIGZyb20gJ3BhdGgnO1xuaW1wb3J0IHsgRG9ja2VySW1hZ2VEZXN0aW5hdGlvbiB9IGZyb20gJ0Bhd3MtY2RrL2Nsb3VkLWFzc2VtYmx5LXNjaGVtYSc7XG5pbXBvcnQgeyBEb2NrZXJJbWFnZU1hbmlmZXN0RW50cnkgfSBmcm9tICcuLi8uLi9hc3NldC1tYW5pZmVzdCc7XG5pbXBvcnQgeyBFdmVudFR5cGUgfSBmcm9tICcuLi8uLi9wcm9ncmVzcyc7XG5pbXBvcnQgeyBJQXNzZXRIYW5kbGVyLCBJSGFuZGxlckhvc3QgfSBmcm9tICcuLi9hc3NldC1oYW5kbGVyJztcbmltcG9ydCB7IERvY2tlciB9IGZyb20gJy4uL2RvY2tlcic7XG5pbXBvcnQgeyByZXBsYWNlQXdzUGxhY2Vob2xkZXJzIH0gZnJvbSAnLi4vcGxhY2Vob2xkZXJzJztcbmltcG9ydCB7IHNoZWxsIH0gZnJvbSAnLi4vc2hlbGwnO1xuXG5leHBvcnQgY2xhc3MgQ29udGFpbmVySW1hZ2VBc3NldEhhbmRsZXIgaW1wbGVtZW50cyBJQXNzZXRIYW5kbGVyIHtcbiAgcHJpdmF0ZSByZWFkb25seSBkb2NrZXIgPSBuZXcgRG9ja2VyKG0gPT4gdGhpcy5ob3N0LmVtaXRNZXNzYWdlKEV2ZW50VHlwZS5ERUJVRywgbSkpO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgcmVhZG9ubHkgd29ya0Rpcjogc3RyaW5nLFxuICAgIHByaXZhdGUgcmVhZG9ubHkgYXNzZXQ6IERvY2tlckltYWdlTWFuaWZlc3RFbnRyeSxcbiAgICBwcml2YXRlIHJlYWRvbmx5IGhvc3Q6IElIYW5kbGVySG9zdCkge1xuICB9XG5cbiAgcHVibGljIGFzeW5jIHB1Ymxpc2goKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc3QgZGVzdGluYXRpb24gPSBhd2FpdCByZXBsYWNlQXdzUGxhY2Vob2xkZXJzKHRoaXMuYXNzZXQuZGVzdGluYXRpb24sIHRoaXMuaG9zdC5hd3MpO1xuICAgIGNvbnN0IGVjciA9IGF3YWl0IHRoaXMuaG9zdC5hd3MuZWNyQ2xpZW50KGRlc3RpbmF0aW9uKTtcbiAgICBjb25zdCBhY2NvdW50ID0gYXN5bmMgKCkgPT4gKGF3YWl0IHRoaXMuaG9zdC5hd3MuZGlzY292ZXJDdXJyZW50QWNjb3VudCgpKT8uYWNjb3VudElkO1xuICAgIGNvbnN0IHJlcG9VcmkgPSBhd2FpdCByZXBvc2l0b3J5VXJpKGVjciwgZGVzdGluYXRpb24ucmVwb3NpdG9yeU5hbWUpO1xuXG4gICAgaWYgKCFyZXBvVXJpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIEVDUiByZXBvc2l0b3J5IG5hbWVkICcke2Rlc3RpbmF0aW9uLnJlcG9zaXRvcnlOYW1lfScgaW4gYWNjb3VudCAke2F3YWl0IGFjY291bnQoKX0uIElzIHRoaXMgYWNjb3VudCBib290c3RyYXBwZWQ/YCk7XG4gICAgfVxuXG4gICAgY29uc3QgaW1hZ2VVcmkgPSBgJHtyZXBvVXJpfToke2Rlc3RpbmF0aW9uLmltYWdlVGFnfWA7XG5cbiAgICBpZiAoYXdhaXQgdGhpcy5kZXN0aW5hdGlvbkFscmVhZHlFeGlzdHMoZWNyLCBkZXN0aW5hdGlvbiwgaW1hZ2VVcmkpKSB7IHJldHVybjsgfVxuICAgIGlmICh0aGlzLmhvc3QuYWJvcnRlZCkgeyByZXR1cm47IH1cblxuICAgIC8vIExvZ2luIGJlZm9yZSBidWlsZCBzbyB0aGF0IHRoZSBEb2NrZXJmaWxlIGNhbiByZWZlcmVuY2UgaW1hZ2VzIGluIHRoZSBFQ1IgcmVwb1xuICAgIGF3YWl0IHRoaXMuZG9ja2VyLmxvZ2luKGVjcik7XG5cbiAgICBjb25zdCBsb2NhbFRhZ05hbWUgPSB0aGlzLmFzc2V0LnNvdXJjZS5leGVjdXRhYmxlXG4gICAgICA/IGF3YWl0IHRoaXMuYnVpbGRFeHRlcm5hbEFzc2V0KHRoaXMuYXNzZXQuc291cmNlLmV4ZWN1dGFibGUpXG4gICAgICA6IGF3YWl0IHRoaXMuYnVpbGREaXJlY3RvcnlBc3NldCgpO1xuXG4gICAgaWYgKGxvY2FsVGFnTmFtZSA9PT0gdW5kZWZpbmVkIHx8IHRoaXMuaG9zdC5hYm9ydGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5ob3N0LmVtaXRNZXNzYWdlKEV2ZW50VHlwZS5VUExPQUQsIGBQdXNoICR7aW1hZ2VVcml9YCk7XG4gICAgaWYgKHRoaXMuaG9zdC5hYm9ydGVkKSB7IHJldHVybjsgfVxuICAgIGF3YWl0IHRoaXMuZG9ja2VyLnRhZyhsb2NhbFRhZ05hbWUsIGltYWdlVXJpKTtcbiAgICBhd2FpdCB0aGlzLmRvY2tlci5wdXNoKGltYWdlVXJpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBCdWlsZCBhIChsb2NhbCkgRG9ja2VyIGFzc2V0IGZyb20gYSBkaXJlY3Rvcnkgd2l0aCBhIERvY2tlcmZpbGVcbiAgICpcbiAgICogVGFncyB1bmRlciBhIGRldGVybWluaXN0aWMsIHVuaXF1ZSwgbG9jYWwgaWRlbnRpZmllciB3aWNoIHdpbGwgc2tpcFxuICAgKiB0aGUgYnVpbGQgaWYgaXQgYWxyZWFkeSBleGlzdHMuXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIGJ1aWxkRGlyZWN0b3J5QXNzZXQoKTogUHJvbWlzZTxzdHJpbmcgfCB1bmRlZmluZWQ+IHtcbiAgICBjb25zdCBsb2NhbFRhZ05hbWUgPSBgY2RrYXNzZXQtJHt0aGlzLmFzc2V0LmlkLmFzc2V0SWQudG9Mb3dlckNhc2UoKX1gO1xuXG4gICAgaWYgKCEoYXdhaXQgdGhpcy5pc0ltYWdlQ2FjaGVkKGxvY2FsVGFnTmFtZSkpKSB7XG4gICAgICBpZiAodGhpcy5ob3N0LmFib3J0ZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuXG4gICAgICBhd2FpdCB0aGlzLmJ1aWxkSW1hZ2UobG9jYWxUYWdOYW1lKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbG9jYWxUYWdOYW1lO1xuICB9XG5cbiAgLyoqXG4gICAqIEJ1aWxkIGEgKGxvY2FsKSBEb2NrZXIgYXNzZXQgYnkgcnVubmluZyBhbiBleHRlcm5hbCBjb21tYW5kXG4gICAqXG4gICAqIEV4dGVybmFsIGNvbW1hbmQgaXMgcmVzcG9uc2libGUgZm9yIGRlZHVwbGljYXRpbmcgdGhlIGJ1aWxkIGlmIHBvc3NpYmxlLFxuICAgKiBhbmQgaXMgZXhwZWN0ZWQgdG8gcmV0dXJuIHRoZSBnZW5lcmF0ZWQgaW1hZ2UgaWRlbnRpZmllciBvbiBzdGRvdXQuXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIGJ1aWxkRXh0ZXJuYWxBc3NldChleGVjdXRhYmxlOiBzdHJpbmdbXSk6IFByb21pc2U8c3RyaW5nIHwgdW5kZWZpbmVkPiB7XG4gICAgdGhpcy5ob3N0LmVtaXRNZXNzYWdlKEV2ZW50VHlwZS5CVUlMRCwgYEJ1aWxkaW5nIERvY2tlciBpbWFnZSB1c2luZyBjb21tYW5kICcke2V4ZWN1dGFibGV9J2ApO1xuICAgIGlmICh0aGlzLmhvc3QuYWJvcnRlZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG5cbiAgICByZXR1cm4gKGF3YWl0IHNoZWxsKGV4ZWN1dGFibGUsIHsgcXVpZXQ6IHRydWUgfSkpLnRyaW0oKTtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIENoZWNrIHdoZXRoZXIgdGhlIGltYWdlIGFscmVhZHkgZXhpc3RzIGluIHRoZSBFQ1IgcmVwb1xuICAgKlxuICAgKiBVc2UgdGhlIGZpZWxkcyBmcm9tIHRoZSBkZXN0aW5hdGlvbiB0byBkbyB0aGUgYWN0dWFsIGNoZWNrLiBUaGUgaW1hZ2VVcmlcbiAgICogc2hvdWxkIGNvcnJlc3BvbmQgdG8gdGhhdCwgYnV0IGlzIG9ubHkgdXNlZCB0byBwcmludCBEb2NrZXIgaW1hZ2UgbG9jYXRpb25cbiAgICogZm9yIHVzZXIgYmVuZWZpdCAodGhlIGZvcm1hdCBpcyBzbGlnaHRseSBkaWZmZXJlbnQpLlxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBkZXN0aW5hdGlvbkFscmVhZHlFeGlzdHMoZWNyOiBBV1MuRUNSLCBkZXN0aW5hdGlvbjogRG9ja2VySW1hZ2VEZXN0aW5hdGlvbiwgaW1hZ2VVcmk6IHN0cmluZyk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIHRoaXMuaG9zdC5lbWl0TWVzc2FnZShFdmVudFR5cGUuQ0hFQ0ssIGBDaGVjayAke2ltYWdlVXJpfWApO1xuICAgIGlmIChhd2FpdCBpbWFnZUV4aXN0cyhlY3IsIGRlc3RpbmF0aW9uLnJlcG9zaXRvcnlOYW1lLCBkZXN0aW5hdGlvbi5pbWFnZVRhZykpIHtcbiAgICAgIHRoaXMuaG9zdC5lbWl0TWVzc2FnZShFdmVudFR5cGUuRk9VTkQsIGBGb3VuZCAke2ltYWdlVXJpfWApO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBidWlsZEltYWdlKGxvY2FsVGFnTmFtZTogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc3Qgc291cmNlID0gdGhpcy5hc3NldC5zb3VyY2U7XG4gICAgaWYgKCFzb3VyY2UuZGlyZWN0b3J5KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYCdkaXJlY3RvcnknIGlzIGV4cGVjdGVkIGluIHRoZSBEb2NrZXJJbWFnZSBhc3NldCBzb3VyY2UsIGdvdDogJHtKU09OLnN0cmluZ2lmeShzb3VyY2UpfWApO1xuICAgIH1cblxuICAgIGNvbnN0IGZ1bGxQYXRoID0gcGF0aC5yZXNvbHZlKHRoaXMud29ya0Rpciwgc291cmNlLmRpcmVjdG9yeSk7XG4gICAgdGhpcy5ob3N0LmVtaXRNZXNzYWdlKEV2ZW50VHlwZS5CVUlMRCwgYEJ1aWxkaW5nIERvY2tlciBpbWFnZSBhdCAke2Z1bGxQYXRofWApO1xuXG4gICAgYXdhaXQgdGhpcy5kb2NrZXIuYnVpbGQoe1xuICAgICAgZGlyZWN0b3J5OiBmdWxsUGF0aCxcbiAgICAgIHRhZzogbG9jYWxUYWdOYW1lLFxuICAgICAgYnVpbGRBcmdzOiBzb3VyY2UuZG9ja2VyQnVpbGRBcmdzLFxuICAgICAgdGFyZ2V0OiBzb3VyY2UuZG9ja2VyQnVpbGRUYXJnZXQsXG4gICAgICBmaWxlOiBzb3VyY2UuZG9ja2VyRmlsZSxcbiAgICB9KTtcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgaXNJbWFnZUNhY2hlZChsb2NhbFRhZ05hbWU6IHN0cmluZyk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIGlmIChhd2FpdCB0aGlzLmRvY2tlci5leGlzdHMobG9jYWxUYWdOYW1lKSkge1xuICAgICAgdGhpcy5ob3N0LmVtaXRNZXNzYWdlKEV2ZW50VHlwZS5DQUNIRUQsIGBDYWNoZWQgJHtsb2NhbFRhZ05hbWV9YCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gaW1hZ2VFeGlzdHMoZWNyOiBBV1MuRUNSLCByZXBvc2l0b3J5TmFtZTogc3RyaW5nLCBpbWFnZVRhZzogc3RyaW5nKSB7XG4gIHRyeSB7XG4gICAgYXdhaXQgZWNyLmRlc2NyaWJlSW1hZ2VzKHsgcmVwb3NpdG9yeU5hbWUsIGltYWdlSWRzOiBbeyBpbWFnZVRhZyB9XSB9KS5wcm9taXNlKCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAoZS5jb2RlICE9PSAnSW1hZ2VOb3RGb3VuZEV4Y2VwdGlvbicpIHsgdGhyb3cgZTsgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG4vKipcbiAqIFJldHVybiB0aGUgVVJJIGZvciB0aGUgcmVwb3NpdG9yeSB3aXRoIHRoZSBnaXZlbiBuYW1lXG4gKlxuICogUmV0dXJucyB1bmRlZmluZWQgaWYgdGhlIHJlcG9zaXRvcnkgZG9lcyBub3QgZXhpc3QuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHJlcG9zaXRvcnlVcmkoZWNyOiBBV1MuRUNSLCByZXBvc2l0b3J5TmFtZTogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmcgfCB1bmRlZmluZWQ+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGVjci5kZXNjcmliZVJlcG9zaXRvcmllcyh7IHJlcG9zaXRvcnlOYW1lczogW3JlcG9zaXRvcnlOYW1lXSB9KS5wcm9taXNlKCk7XG4gICAgcmV0dXJuIChyZXNwb25zZS5yZXBvc2l0b3JpZXMgfHwgW10pWzBdPy5yZXBvc2l0b3J5VXJpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKGUuY29kZSAhPT0gJ1JlcG9zaXRvcnlOb3RGb3VuZEV4Y2VwdGlvbicpIHsgdGhyb3cgZTsgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbn1cbiJdfQ==