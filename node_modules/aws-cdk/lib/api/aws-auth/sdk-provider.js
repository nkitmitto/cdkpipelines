"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SdkProvider = void 0;
const https = require("https");
const os = require("os");
const path = require("path");
const cxapi = require("@aws-cdk/cx-api");
const AWS = require("aws-sdk");
const fs = require("fs-extra");
const logging_1 = require("../../logging");
const functions_1 = require("../../util/functions");
const credential_plugins_1 = require("../aws-auth/credential-plugins");
const awscli_compatible_1 = require("./awscli-compatible");
const sdk_1 = require("./sdk");
// Some configuration that can only be achieved by setting
// environment variables.
process.env.AWS_STS_REGIONAL_ENDPOINTS = 'regional';
process.env.AWS_NODEJS_CONNECTION_REUSE_ENABLED = '1';
const CACHED_ACCOUNT = Symbol('cached_account');
const CACHED_DEFAULT_CREDENTIALS = Symbol('cached_default_credentials');
/**
 * Creates instances of the AWS SDK appropriate for a given account/region.
 *
 * Behavior is as follows:
 *
 * - First, a set of "base" credentials are established
 *   - If a target environment is given and the default ("current") SDK credentials are for
 *     that account, return those; otherwise
 *   - If a target environment is given, scan all credential provider plugins
 *     for credentials, and return those if found; otherwise
 *   - Return default ("current") SDK credentials, noting that they might be wrong.
 *
 * - Second, a role may optionally need to be assumed. Use the base credentials
 *   established in the previous process to assume that role.
 *   - If assuming the role fails and the base credentials are for the correct
 *     account, return those. This is a fallback for people who are trying to interact
 *     with a Default Synthesized stack and already have right credentials setup.
 *
 *     Typical cases we see in the wild:
 *     - Credential plugin setup that, although not recommended, works for them
 *     - Seeded terminal with `ReadOnly` credentials in order to do `cdk diff`--the `ReadOnly`
 *       role doesn't have `sts:AssumeRole` and will fail for no real good reason.
 */
class SdkProvider {
    constructor(defaultChain, 
    /**
     * Default region
     */
    defaultRegion, sdkOptions = {}) {
        this.defaultChain = defaultChain;
        this.defaultRegion = defaultRegion;
        this.sdkOptions = sdkOptions;
        this.plugins = new credential_plugins_1.CredentialPlugins();
    }
    /**
     * Create a new SdkProvider which gets its defaults in a way that behaves like the AWS CLI does
     *
     * The AWS SDK for JS behaves slightly differently from the AWS CLI in a number of ways; see the
     * class `AwsCliCompatible` for the details.
     */
    static async withAwsCliCompatibleDefaults(options = {}) {
        var _a;
        const sdkOptions = parseHttpOptions((_a = options.httpOptions) !== null && _a !== void 0 ? _a : {});
        const chain = await awscli_compatible_1.AwsCliCompatible.credentialChain({
            profile: options.profile,
            ec2instance: options.ec2creds,
            containerCreds: options.containerCreds,
            httpOptions: sdkOptions.httpOptions,
        });
        const region = await awscli_compatible_1.AwsCliCompatible.region({
            profile: options.profile,
            ec2instance: options.ec2creds,
        });
        return new SdkProvider(chain, region, sdkOptions);
    }
    /**
     * Return an SDK which can do operations in the given environment
     *
     * The `environment` parameter is resolved first (see `resolveEnvironment()`).
     */
    async forEnvironment(environment, mode, options) {
        const env = await this.resolveEnvironment(environment);
        const baseCreds = await this.obtainBaseCredentials(env.account, mode);
        // At this point, we need at least SOME credentials
        if (baseCreds.source === 'none') {
            throw new Error(fmtObtainCredentialsError(env.account, baseCreds));
        }
        // Simple case is if we don't need to "assumeRole" here. If so, we must now have credentials for the right
        // account.
        if ((options === null || options === void 0 ? void 0 : options.assumeRoleArn) === undefined) {
            if (baseCreds.source === 'incorrectDefault') {
                throw new Error(fmtObtainCredentialsError(env.account, baseCreds));
            }
            return new sdk_1.SDK(baseCreds.credentials, env.region, this.sdkOptions);
        }
        // We will proceed to AssumeRole using whatever we've been given.
        const sdk = await this.withAssumedRole(baseCreds, options.assumeRoleArn, options.assumeRoleExternalId, env.region);
        // Exercise the AssumeRoleCredentialsProvider we've gotten at least once so
        // we can determine whether the AssumeRole call succeeds or not.
        try {
            await sdk.forceCredentialRetrieval();
            return sdk;
        }
        catch (e) {
            // AssumeRole failed. Proceed and warn *if and only if* the baseCredentials were already for the right account
            // or returned from a plugin. This is to cover some current setups for people using plugins or preferring to
            // feed the CLI credentials which are sufficient by themselves. Prefer to assume the correct role if we can,
            // but if we can't then let's just try with available credentials anyway.
            if (baseCreds.source === 'correctDefault' || baseCreds.source === 'plugin') {
                logging_1.debug(e.message);
                logging_1.warning(`${fmtObtainedCredentials(baseCreds)} could not be used to assume '${options.assumeRoleArn}', but are for the right account. Proceeding anyway.`);
                return new sdk_1.SDK(baseCreds.credentials, env.region, this.sdkOptions);
            }
            throw e;
        }
    }
    /**
     * Return the partition that base credentials are for
     *
     * Returns `undefined` if there are no base credentials.
     */
    async baseCredentialsPartition(environment, mode) {
        const env = await this.resolveEnvironment(environment);
        const baseCreds = await this.obtainBaseCredentials(env.account, mode);
        if (baseCreds.source === 'none') {
            return undefined;
        }
        return (await new sdk_1.SDK(baseCreds.credentials, env.region, this.sdkOptions).currentAccount()).partition;
    }
    /**
     * Resolve the environment for a stack
     *
     * Replaces the magic values `UNKNOWN_REGION` and `UNKNOWN_ACCOUNT`
     * with the defaults for the current SDK configuration (`~/.aws/config` or
     * otherwise).
     *
     * It is an error if `UNKNOWN_ACCOUNT` is used but the user hasn't configured
     * any SDK credentials.
     */
    async resolveEnvironment(env) {
        var _a;
        const region = env.region !== cxapi.UNKNOWN_REGION ? env.region : this.defaultRegion;
        const account = env.account !== cxapi.UNKNOWN_ACCOUNT ? env.account : (_a = (await this.defaultAccount())) === null || _a === void 0 ? void 0 : _a.accountId;
        if (!account) {
            throw new Error('Unable to resolve AWS account to use. It must be either configured when you define your CDK or through the environment');
        }
        return {
            region,
            account,
            name: cxapi.EnvironmentUtils.format(account, region),
        };
    }
    /**
     * The account we'd auth into if we used default credentials.
     *
     * Default credentials are the set of ambiently configured credentials using
     * one of the environment variables, or ~/.aws/credentials, or the *one*
     * profile that was passed into the CLI.
     *
     * Might return undefined if there are no default/ambient credentials
     * available (in which case the user should better hope they have
     * credential plugins configured).
     *
     * Uses a cache to avoid STS calls if we don't need 'em.
     */
    defaultAccount() {
        return functions_1.cached(this, CACHED_ACCOUNT, async () => {
            try {
                const creds = await this.defaultCredentials();
                const accessKeyId = creds.accessKeyId;
                if (!accessKeyId) {
                    throw new Error('Unable to resolve AWS credentials (setup with "aws configure")');
                }
                return await new sdk_1.SDK(creds, this.defaultRegion, this.sdkOptions).currentAccount();
            }
            catch (e) {
                logging_1.debug('Unable to determine the default AWS account:', e);
                return undefined;
            }
        });
    }
    /**
     * Get credentials for the given account ID in the given mode
     *
     * 1. Use the default credentials if the destination account matches the
     *    current credentials' account.
     * 2. Otherwise try all credential plugins.
     * 3. Fail if neither of these yield any credentials.
     * 4. Return a failure if any of them returned credentials
     */
    async obtainBaseCredentials(accountId, mode) {
        var _a;
        // First try 'current' credentials
        const defaultAccountId = (_a = (await this.defaultAccount())) === null || _a === void 0 ? void 0 : _a.accountId;
        if (defaultAccountId === accountId) {
            return { source: 'correctDefault', credentials: await this.defaultCredentials() };
        }
        // Then try the plugins
        const pluginCreds = await this.plugins.fetchCredentialsFor(accountId, mode);
        if (pluginCreds) {
            return { source: 'plugin', ...pluginCreds };
        }
        // Fall back to default credentials with a note that they're not the right ones yet
        if (defaultAccountId !== undefined) {
            return {
                source: 'incorrectDefault',
                accountId: defaultAccountId,
                credentials: await this.defaultCredentials(),
                unusedPlugins: this.plugins.availablePluginNames,
            };
        }
        // Apparently we didn't find any at all
        return {
            source: 'none',
            unusedPlugins: this.plugins.availablePluginNames,
        };
    }
    /**
     * Resolve the default chain to the first set of credentials that is available
     */
    defaultCredentials() {
        return functions_1.cached(this, CACHED_DEFAULT_CREDENTIALS, () => {
            logging_1.debug('Resolving default credentials');
            return this.defaultChain.resolvePromise();
        });
    }
    /**
     * Return an SDK which uses assumed role credentials
     *
     * The base credentials used to retrieve the assumed role credentials will be the
     * same credentials returned by obtainCredentials if an environment and mode is passed,
     * otherwise it will be the current credentials.
     */
    async withAssumedRole(masterCredentials, roleArn, externalId, region) {
        logging_1.debug(`Assuming role '${roleArn}'.`);
        region = region !== null && region !== void 0 ? region : this.defaultRegion;
        const creds = new AWS.ChainableTemporaryCredentials({
            params: {
                RoleArn: roleArn,
                ...externalId ? { ExternalId: externalId } : {},
                RoleSessionName: `aws-cdk-${safeUsername()}`,
            },
            stsConfig: {
                region,
                ...this.sdkOptions,
            },
            masterCredentials: masterCredentials.credentials,
        });
        return new sdk_1.SDK(creds, region, this.sdkOptions, {
            assumeRoleCredentialsSourceDescription: fmtObtainedCredentials(masterCredentials),
        });
    }
}
exports.SdkProvider = SdkProvider;
const DEFAULT_CONNECTION_TIMEOUT = 10000;
const DEFAULT_TIMEOUT = 300000;
/**
 * Get HTTP options for the SDK
 *
 * Read from user input or environment variables.
 *
 * Returns a complete `ConfigurationOptions` object because that's where
 * `customUserAgent` lives, but `httpOptions` is the most important attribute.
 */
function parseHttpOptions(options) {
    var _a;
    const config = {};
    config.httpOptions = {};
    config.httpOptions.connectTimeout = DEFAULT_CONNECTION_TIMEOUT;
    config.httpOptions.timeout = DEFAULT_TIMEOUT;
    let userAgent = options.userAgent;
    if (userAgent == null) {
        // Find the package.json from the main toolkit
        const pkg = JSON.parse((_a = readIfPossible(path.join(__dirname, '..', '..', '..', 'package.json'))) !== null && _a !== void 0 ? _a : '{}');
        userAgent = `${pkg.name}/${pkg.version}`;
    }
    config.customUserAgent = userAgent;
    const proxyAddress = options.proxyAddress || httpsProxyFromEnvironment();
    const caBundlePath = options.caBundlePath || caBundlePathFromEnvironment();
    if (proxyAddress && caBundlePath) {
        throw new Error(`At the moment, cannot specify Proxy (${proxyAddress}) and CA Bundle (${caBundlePath}) at the same time. See https://github.com/aws/aws-cdk/issues/5804`);
        // Maybe it's possible after all, but I've been staring at
        // https://github.com/TooTallNate/node-proxy-agent/blob/master/index.js#L79
        // a while now trying to figure out what to pass in so that the underlying Agent
        // object will get the 'ca' argument. It's not trivial and I don't want to risk it.
    }
    if (proxyAddress) { // Ignore empty string on purpose
        // https://aws.amazon.com/blogs/developer/using-the-aws-sdk-for-javascript-from-behind-a-proxy/
        logging_1.debug('Using proxy server: %s', proxyAddress);
        // eslint-disable-next-line @typescript-eslint/no-require-imports
        const ProxyAgent = require('proxy-agent');
        config.httpOptions.agent = new ProxyAgent(proxyAddress);
    }
    if (caBundlePath) {
        logging_1.debug('Using CA bundle path: %s', caBundlePath);
        config.httpOptions.agent = new https.Agent({
            ca: readIfPossible(caBundlePath),
            keepAlive: true,
        });
    }
    return config;
}
/**
 * Find and return the configured HTTPS proxy address
 */
function httpsProxyFromEnvironment() {
    if (process.env.https_proxy) {
        return process.env.https_proxy;
    }
    if (process.env.HTTPS_PROXY) {
        return process.env.HTTPS_PROXY;
    }
    return undefined;
}
/**
 * Find and return a CA certificate bundle path to be passed into the SDK.
 */
function caBundlePathFromEnvironment() {
    if (process.env.aws_ca_bundle) {
        return process.env.aws_ca_bundle;
    }
    if (process.env.AWS_CA_BUNDLE) {
        return process.env.AWS_CA_BUNDLE;
    }
    return undefined;
}
/**
 * Read a file if it exists, or return undefined
 *
 * Not async because it is used in the constructor
 */
function readIfPossible(filename) {
    try {
        if (!fs.pathExistsSync(filename)) {
            return undefined;
        }
        return fs.readFileSync(filename, { encoding: 'utf-8' });
    }
    catch (e) {
        logging_1.debug(e);
        return undefined;
    }
}
/**
 * Return the username with characters invalid for a RoleSessionName removed
 *
 * @see https://docs.aws.amazon.com/STS/latest/APIReference/API_AssumeRole.html#API_AssumeRole_RequestParameters
 */
function safeUsername() {
    return os.userInfo().username.replace(/[^\w+=,.@-]/g, '@');
}
/**
 * Isolating the code that translates calculation errors into human error messages
 *
 * We cover the following cases:
 *
 * - No credentials are available at all
 * - Default credentials are for the wrong account
 */
function fmtObtainCredentialsError(targetAccountId, obtainResult) {
    const msg = [`Need to perform AWS calls for account ${targetAccountId}`];
    switch (obtainResult.source) {
        case 'incorrectDefault':
            msg.push(`but the current credentials are for ${obtainResult.accountId}`);
            break;
        case 'none':
            msg.push('but no credentials have been configured');
    }
    if (obtainResult.unusedPlugins.length > 0) {
        msg.push(`and none of these plugins found any: ${obtainResult.unusedPlugins.join(', ')}`);
    }
    return msg.join(', ');
}
/**
 * Format a message indicating where we got base credentials for the assume role
 *
 * We cover the following cases:
 *
 * - Default credentials for the right account
 * - Default credentials for the wrong account
 * - Credentials returned from a plugin
 */
function fmtObtainedCredentials(obtainResult) {
    switch (obtainResult.source) {
        case 'correctDefault':
            return 'current credentials';
        case 'plugin':
            return `credentials returned by plugin '${obtainResult.pluginName}'`;
        case 'incorrectDefault':
            const msg = [];
            msg.push(`current credentials (which are for account ${obtainResult.accountId}`);
            if (obtainResult.unusedPlugins.length > 0) {
                msg.push(`, and none of the following plugins provided credentials: ${obtainResult.unusedPlugins.join(', ')}`);
            }
            msg.push(')');
            return msg.join('');
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2RrLXByb3ZpZGVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsic2RrLXByb3ZpZGVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUFBLCtCQUErQjtBQUMvQix5QkFBeUI7QUFDekIsNkJBQTZCO0FBQzdCLHlDQUF5QztBQUN6QywrQkFBK0I7QUFFL0IsK0JBQStCO0FBQy9CLDJDQUErQztBQUMvQyxvREFBOEM7QUFDOUMsdUVBQW1FO0FBRW5FLDJEQUF1RDtBQUN2RCwrQkFBa0M7QUFHbEMsMERBQTBEO0FBQzFELHlCQUF5QjtBQUN6QixPQUFPLENBQUMsR0FBRyxDQUFDLDBCQUEwQixHQUFHLFVBQVUsQ0FBQztBQUNwRCxPQUFPLENBQUMsR0FBRyxDQUFDLG1DQUFtQyxHQUFHLEdBQUcsQ0FBQztBQTJEdEQsTUFBTSxjQUFjLEdBQUcsTUFBTSxDQUFDLGdCQUFnQixDQUFDLENBQUM7QUFDaEQsTUFBTSwwQkFBMEIsR0FBRyxNQUFNLENBQUMsNEJBQTRCLENBQUMsQ0FBQztBQUV4RTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQXNCRztBQUNILE1BQWEsV0FBVztJQTBCdEIsWUFDbUIsWUFBeUM7SUFDMUQ7O09BRUc7SUFDYSxhQUFxQixFQUNwQixhQUFtQyxFQUFFO1FBTHJDLGlCQUFZLEdBQVosWUFBWSxDQUE2QjtRQUkxQyxrQkFBYSxHQUFiLGFBQWEsQ0FBUTtRQUNwQixlQUFVLEdBQVYsVUFBVSxDQUEyQjtRQVJ2QyxZQUFPLEdBQUcsSUFBSSxzQ0FBaUIsRUFBRSxDQUFDO0lBU25ELENBQUM7SUFoQ0Q7Ozs7O09BS0c7SUFDSSxNQUFNLENBQUMsS0FBSyxDQUFDLDRCQUE0QixDQUFDLFVBQThCLEVBQUU7O1FBQy9FLE1BQU0sVUFBVSxHQUFHLGdCQUFnQixPQUFDLE9BQU8sQ0FBQyxXQUFXLG1DQUFJLEVBQUUsQ0FBQyxDQUFDO1FBRS9ELE1BQU0sS0FBSyxHQUFHLE1BQU0sb0NBQWdCLENBQUMsZUFBZSxDQUFDO1lBQ25ELE9B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QU0sR0FBRyxDQUFDLEVBQUU7UUFDekMsR0FBRyxDQUFDLElBQUksQ0FBQyx3Q0FBd0MsWUFBWSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDO0tBQzNGO0lBQ0QsT0FBTyxHQUFHLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO0FBQ3hCLENBQUM7QUFFRDs7Ozs7Ozs7R0FRRztBQUNILFNBQVMsc0JBQXNCLENBQzdCLFlBQXNFO0lBQ3RFLFFBQVEsWUFBWSxDQUFDLE1BQU0sRUFBRTtRQUMzQixLQUFLLGdCQUFnQjtZQUNuQixPQUFPLHFCQUFxQixDQUFDO1FBQy9CLEtBQUssUUFBUTtZQUNYLE9BQU8sbUNBQW1DLFlBQVksQ0FBQyxVQUFVLEdBQUcsQ0FBQztRQUN2RSxLQUFLLGtCQUFrQjtZQUNyQixNQUFNLEdBQUcsR0FBRyxFQUFFLENBQUM7WUFDZixHQUFHLENBQUMsSUFBSSxDQUFDLDhDQUE4QyxZQUFZLENBQUMsU0FBUyxFQUFFLENBQUMsQ0FBQztZQUVqRixJQUFJLFlBQVksQ0FBQyxhQUFhLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRTtnQkFDekMsR0FBRyxDQUFDLElBQUksQ0FBQyw2REFBNkQsWUFBWSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDO2FBQ2hIO1lBQ0QsR0FBRyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztZQUVkLE9BQU8sR0FBRyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQztLQUN2QjtBQUNILENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBodHRwcyBmcm9tICdodHRwcyc7XG5pbXBvcnQgKiBhcyBvcyBmcm9tICdvcyc7XG5pbXBvcnQgKiBhcyBwYXRoIGZyb20gJ3BhdGgnO1xuaW1wb3J0ICogYXMgY3hhcGkgZnJvbSAnQGF3cy1jZGsvY3gtYXBpJztcbmltcG9ydCAqIGFzIEFXUyBmcm9tICdhd3Mtc2RrJztcbmltcG9ydCB0eXBlIHsgQ29uZmlndXJhdGlvbk9wdGlvbnMgfSBmcm9tICdhd3Mtc2RrL2xpYi9jb25maWctYmFzZSc7XG5pbXBvcnQgKiBhcyBmcyBmcm9tICdmcy1leHRyYSc7XG5pbXBvcnQgeyBkZWJ1Zywgd2FybmluZyB9IGZyb20gJy4uLy4uL2xvZ2dpbmcnO1xuaW1wb3J0IHsgY2FjaGVkIH0gZnJvbSAnLi4vLi4vdXRpbC9mdW5jdGlvbnMnO1xuaW1wb3J0IHsgQ3JlZGVudGlhbFBsdWdpbnMgfSBmcm9tICcuLi9hd3MtYXV0aC9jcmVkZW50aWFsLXBsdWdpbnMnO1xuaW1wb3J0IHsgTW9kZSB9IGZyb20gJy4uL2F3cy1hdXRoL2NyZWRlbnRpYWxzJztcbmltcG9ydCB7IEF3c0NsaUNvbXBhdGlibGUgfSBmcm9tICcuL2F3c2NsaS1jb21wYXRpYmxlJztcbmltcG9ydCB7IElTREssIFNESyB9IGZyb20gJy4vc2RrJztcblxuXG4vLyBTb21lIGNvbmZpZ3VyYXRpb24gdGhhdCBjYW4gb25seSBiZSBhY2hpZXZlZCBieSBzZXR0aW5nXG4vLyBlbnZpcm9ubWVudCB2YXJpYWJsZXMuXG5wcm9jZXNzLmVudi5BV1NfU1RTX1JFR0lPTkFMX0VORFBPSU5UUyA9ICdyZWdpb25hbCc7XG5wcm9jZXNzLmVudi5BV1NfTk9ERUpTX0NPTk5FQ1RJT05fUkVVU0VfRU5BQkxFRCA9ICcxJztcblxuLyoqXG4gKiBPcHRpb25zIGZvciB0aGUgZGVmYXVsdCBTREsgcHJvdmlkZXJcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBTZGtQcm92aWRlck9wdGlvbnMge1xuICAvKipcbiAgICogUHJvZmlsZSB0byByZWFkIGZyb20gfi8uYXdzXG4gICAqXG4gICAqIEBkZWZhdWx0IC0gTm8gcHJvZmlsZVxuICAgKi9cbiAgcmVhZG9ubHkgcHJvZmlsZT86IHN0cmluZztcblxuICAvKipcbiAgICogV2hldGhlciB3ZSBzaG91bGQgY2hlY2sgZm9yIEVDMiBjcmVkZW50aWFsc1xuICAgKlxuICAgKiBAZGVmYXVsdCAtIEF1dG9kZXRlY3RcbiAgICovXG4gIHJlYWRvbmx5IGVjMmNyZWRzPzogYm9vbGVhbjtcblxuICAvKipcbiAgICogV2hldGhlciB3ZSBzaG91bGQgY2hlY2sgZm9yIGNvbnRhaW5lciBjcmVkZW50aWFsc1xuICAgKlxuICAgKiBAZGVmYXVsdCAtIEF1dG9kZXRlY3RcbiAgICovXG4gIHJlYWRvbmx5IGNvbnRhaW5lckNyZWRzPzogYm9vbGVhbjtcblxuICAvKipcbiAgICogSFRUUCBvcHRpb25zIGZvciBTREtcbiAgICovXG4gIHJlYWRvbmx5IGh0dHBPcHRpb25zPzogU2RrSHR0cE9wdGlvbnM7XG59XG5cbi8qKlxuICogT3B0aW9ucyBmb3IgaW5kaXZpZHVhbCBTREtzXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgU2RrSHR0cE9wdGlvbnMge1xuICAvKipcbiAgICogUHJveHkgYWRkcmVzcyB0byB1c2VcbiAgICpcbiAgICogQGRlZmF1bHQgTm8gcHJveHlcbiAgICovXG4gIHJlYWRvbmx5IHByb3h5QWRkcmVzcz86IHN0cmluZztcblxuICAvKipcbiAgICogQSBwYXRoIHRvIGEgY2VydGlmaWNhdGUgYnVuZGxlIHRoYXQgY29udGFpbnMgYSBjZXJ0IHRvIGJlIHRydXN0ZWQuXG4gICAqXG4gICAqIEBkZWZhdWx0IE5vIGNlcnRpZmljYXRlIGJ1bmRsZVxuICAgKi9cbiAgcmVhZG9ubHkgY2FCdW5kbGVQYXRoPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgY3VzdG9tIHVzZXIgYWdlbnQgdG8gdXNlLlxuICAgKlxuICAgKiBAZGVmYXVsdCAtIDxwYWNrYWdlLW5hbWU+LzxwYWNrYWdlLXZlcnNpb24+XG4gICAqL1xuICByZWFkb25seSB1c2VyQWdlbnQ/OiBzdHJpbmc7XG59XG5cbmNvbnN0IENBQ0hFRF9BQ0NPVU5UID0gU3ltYm9sKCdjYWNoZWRfYWNjb3VudCcpO1xuY29uc3QgQ0FDSEVEX0RFRkFVTFRfQ1JFREVOVElBTFMgPSBTeW1ib2woJ2NhY2hlZF9kZWZhdWx0X2NyZWRlbnRpYWxzJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBpbnN0YW5jZXMgb2YgdGhlIEFXUyBTREsgYXBwcm9wcmlhdGUgZm9yIGEgZ2l2ZW4gYWNjb3VudC9yZWdpb24uXG4gKlxuICogQmVoYXZpb3IgaXMgYXMgZm9sbG93czpcbiAqXG4gKiAtIEZpcnN0LCBhIHNldCBvZiBcImJhc2VcIiBjcmVkZW50aWFscyBhcmUgZXN0YWJsaXNoZWRcbiAqICAgLSBJZiBhIHRhcmdldCBlbnZpcm9ubWVudCBpcyBnaXZlbiBhbmQgdGhlIGRlZmF1bHQgKFwiY3VycmVudFwiKSBTREsgY3JlZGVudGlhbHMgYXJlIGZvclxuICogICAgIHRoYXQgYWNjb3VudCwgcmV0dXJuIHRob3NlOyBvdGhlcndpc2VcbiAqICAgLSBJZiBhIHRhcmdldCBlbnZpcm9ubWVudCBpcyBnaXZlbiwgc2NhbiBhbGwgY3JlZGVudGlhbCBwcm92aWRlciBwbHVnaW5zXG4gKiAgICAgZm9yIGNyZWRlbnRpYWxzLCBhbmQgcmV0dXJuIHRob3NlIGlmIGZvdW5kOyBvdGhlcndpc2VcbiAqICAgLSBSZXR1cm4gZGVmYXVsdCAoXCJjdXJyZW50XCIpIFNESyBjcmVkZW50aWFscywgbm90aW5nIHRoYXQgdGhleSBtaWdodCBiZSB3cm9uZy5cbiAqXG4gKiAtIFNlY29uZCwgYSByb2xlIG1heSBvcHRpb25hbGx5IG5lZWQgdG8gYmUgYXNzdW1lZC4gVXNlIHRoZSBiYXNlIGNyZWRlbnRpYWxzXG4gKiAgIGVzdGFibGlzaGVkIGluIHRoZSBwcmV2aW91cyBwcm9jZXNzIHRvIGFzc3VtZSB0aGF0IHJvbGUuXG4gKiAgIC0gSWYgYXNzdW1pbmcgdGhlIHJvbGUgZmFpbHMgYW5kIHRoZSBiYXNlIGNyZWRlbnRpYWxzIGFyZSBmb3IgdGhlIGNvcnJlY3RcbiAqICAgICBhY2NvdW50LCByZXR1cm4gdGhvc2UuIFRoaXMgaXMgYSBmYWxsYmFjayBmb3IgcGVvcGxlIHdobyBhcmUgdHJ5aW5nIHRvIGludGVyYWN0XG4gKiAgICAgd2l0aCBhIERlZmF1bHQgU3ludGhlc2l6ZWQgc3RhY2sgYW5kIGFscmVhZHkgaGF2ZSByaWdodCBjcmVkZW50aWFscyBzZXR1cC5cbiAqXG4gKiAgICAgVHlwaWNhbCBjYXNlcyB3ZSBzZWUgaW4gdGhlIHdpbGQ6XG4gKiAgICAgLSBDcmVkZW50aWFsIHBsdWdpbiBzZXR1cCB0aGF0LCBhbHRob3VnaCBub3QgcmVjb21tZW5kZWQsIHdvcmtzIGZvciB0aGVtXG4gKiAgICAgLSBTZWVkZWQgdGVybWluYWwgd2l0aCBgUmVhZE9ubHlgIGNyZWRlbnRpYWxzIGluIG9yZGVyIHRvIGRvIGBjZGsgZGlmZmAtLXRoZSBgUmVhZE9ubHlgXG4gKiAgICAgICByb2xlIGRvZXNuJ3QgaGF2ZSBgc3RzOkFzc3VtZVJvbGVgIGFuZCB3aWxsIGZhaWwgZm9yIG5vIHJlYWwgZ29vZCByZWFzb24uXG4gKi9cbmV4cG9ydCBjbGFzcyBTZGtQcm92aWRlciB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgU2RrUHJvdmlkZXIgd2hpY2ggZ2V0cyBpdHMgZGVmYXVsdHMgaW4gYSB3YXkgdGhhdCBiZWhhdmVzIGxpa2UgdGhlIEFXUyBDTEkgZG9lc1xuICAgKlxuICAgKiBUaGUgQVdTIFNESyBmb3IgSlMgYmVoYXZlcyBzbGlnaHRseSBkaWZmZXJlbnRseSBmcm9tIHRoZSBBV1MgQ0xJIGluIGEgbnVtYmVyIG9mIHdheXM7IHNlZSB0aGVcbiAgICogY2xhc3MgYEF3c0NsaUNvbXBhdGlibGVgIGZvciB0aGUgZGV0YWlscy5cbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgYXN5bmMgd2l0aEF3c0NsaUNvbXBhdGlibGVEZWZhdWx0cyhvcHRpb25zOiBTZGtQcm92aWRlck9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHNka09wdGlvbnMgPSBwYXJzZUh0dHBPcHRpb25zKG9wdGlvbnMuaHR0cE9wdGlvbnMgPz8ge30pO1xuXG4gICAgY29uc3QgY2hhaW4gPSBhd2FpdCBBd3NDbGlDb21wYXRpYmxlLmNyZWRlbnRpYWxDaGFpbih7XG4gICAgICBwcm9maWxlOiBvcHRpb25zLnByb2ZpbGUsXG4gICAgICBlYzJpbnN0YW5jZTogb3B0aW9ucy5lYzJjcmVkcyxcbiAgICAgIGNvbnRhaW5lckNyZWRzOiBvcHRpb25zLmNvbnRhaW5lckNyZWRzLFxuICAgICAgaHR0cE9wdGlvbnM6IHNka09wdGlvbnMuaHR0cE9wdGlvbnMsXG4gICAgfSk7XG4gICAgY29uc3QgcmVnaW9uID0gYXdhaXQgQXdzQ2xpQ29tcGF0aWJsZS5yZWdpb24oe1xuICAgICAgcHJvZmlsZTogb3B0aW9ucy5wcm9maWxlLFxuICAgICAgZWMyaW5zdGFuY2U6IG9wdGlvbnMuZWMyY3JlZHMsXG4gICAgfSk7XG5cbiAgICByZXR1cm4gbmV3IFNka1Byb3ZpZGVyKGNoYWluLCByZWdpb24sIHNka09wdGlvbnMpO1xuICB9XG5cbiAgcHJpdmF0ZSByZWFkb25seSBwbHVnaW5zID0gbmV3IENyZWRlbnRpYWxQbHVnaW5zKCk7XG5cbiAgcHVibGljIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgcmVhZG9ubHkgZGVmYXVsdENoYWluOiBBV1MuQ3JlZGVudGlhbFByb3ZpZGVyQ2hhaW4sXG4gICAgLyoqXG4gICAgICogRGVmYXVsdCByZWdpb25cbiAgICAgKi9cbiAgICBwdWJsaWMgcmVhZG9ubHkgZGVmYXVsdFJlZ2lvbjogc3RyaW5nLFxuICAgIHByaXZhdGUgcmVhZG9ubHkgc2RrT3B0aW9uczogQ29uZmlndXJhdGlvbk9wdGlvbnMgPSB7fSkge1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBhbiBTREsgd2hpY2ggY2FuIGRvIG9wZXJhdGlvbnMgaW4gdGhlIGdpdmVuIGVudmlyb25tZW50XG4gICAqXG4gICAqIFRoZSBgZW52aXJvbm1lbnRgIHBhcmFtZXRlciBpcyByZXNvbHZlZCBmaXJzdCAoc2VlIGByZXNvbHZlRW52aXJvbm1lbnQoKWApLlxuICAgKi9cbiAgcHVibGljIGFzeW5jIGZvckVudmlyb25tZW50KGVudmlyb25tZW50OiBjeGFwaS5FbnZpcm9ubWVudCwgbW9kZTogTW9kZSwgb3B0aW9ucz86IENyZWRlbnRpYWxzT3B0aW9ucyk6IFByb21pc2U8SVNESz4ge1xuICAgIGNvbnN0IGVudiA9IGF3YWl0IHRoaXMucmVzb2x2ZUVudmlyb25tZW50KGVudmlyb25tZW50KTtcbiAgICBjb25zdCBiYXNlQ3JlZHMgPSBhd2FpdCB0aGlzLm9idGFpbkJhc2VDcmVkZW50aWFscyhlbnYuYWNjb3VudCwgbW9kZSk7XG5cbiAgICAvLyBBdCB0aGlzIHBvaW50LCB3ZSBuZWVkIGF0IGxlYXN0IFNPTUUgY3JlZGVudGlhbHNcbiAgICBpZiAoYmFzZUNyZWRzLnNvdXJjZSA9PT0gJ25vbmUnKSB7IHRocm93IG5ldyBFcnJvcihmbXRPYnRhaW5DcmVkZW50aWFsc0Vycm9yKGVudi5hY2NvdW50LCBiYXNlQ3JlZHMpKTsgfVxuXG4gICAgLy8gU2ltcGxlIGNhc2UgaXMgaWYgd2UgZG9uJ3QgbmVlZCB0byBcImFzc3VtZVJvbGVcIiBoZXJlLiBJZiBzbywgd2UgbXVzdCBub3cgaGF2ZSBjcmVkZW50aWFscyBmb3IgdGhlIHJpZ2h0XG4gICAgLy8gYWNjb3VudC5cbiAgICBpZiAob3B0aW9ucz8uYXNzdW1lUm9sZUFybiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoYmFzZUNyZWRzLnNvdXJjZSA9PT0gJ2luY29ycmVjdERlZmF1bHQnKSB7IHRocm93IG5ldyBFcnJvcihmbXRPYnRhaW5DcmVkZW50aWFsc0Vycm9yKGVudi5hY2NvdW50LCBiYXNlQ3JlZHMpKTsgfVxuICAgICAgcmV0dXJuIG5ldyBTREsoYmFzZUNyZWRzLmNyZWRlbnRpYWxzLCBlbnYucmVnaW9uLCB0aGlzLnNka09wdGlvbnMpO1xuICAgIH1cblxuICAgIC8vIFdlIHdpbGwgcHJvY2VlZCB0byBBc3N1bWVSb2xlIHVzaW5nIHdoYXRldmVyIHdlJ3ZlIGJlZW4gZ2l2ZW4uXG4gICAgY29uc3Qgc2RrID0gYXdhaXQgdGhpcy53aXRoQXNzdW1lZFJvbGUoYmFzZUNyZWRzLCBvcHRpb25zLmFzc3VtZVJvbGVBcm4sIG9wdGlvbnMuYXNzdW1lUm9sZUV4dGVybmFsSWQsIGVudi5yZWdpb24pO1xuXG4gICAgLy8gRXhlcmNpc2UgdGhlIEFzc3VtZVJvbGVDcmVkZW50aWFsc1Byb3ZpZGVyIHdlJ3ZlIGdvdHRlbiBhdCBsZWFzdCBvbmNlIHNvXG4gICAgLy8gd2UgY2FuIGRldGVybWluZSB3aGV0aGVyIHRoZSBBc3N1bWVSb2xlIGNhbGwgc3VjY2VlZHMgb3Igbm90LlxuICAgIHRyeSB7XG4gICAgICBhd2FpdCBzZGsuZm9yY2VDcmVkZW50aWFsUmV0cmlldmFsKCk7XG4gICAgICByZXR1cm4gc2RrO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIEFzc3VtZVJvbGUgZmFpbGVkLiBQcm9jZWVkIGFuZCB3YXJuICppZiBhbmQgb25seSBpZiogdGhlIGJhc2VDcmVkZW50aWFscyB3ZXJlIGFscmVhZHkgZm9yIHRoZSByaWdodCBhY2NvdW50XG4gICAgICAvLyBvciByZXR1cm5lZCBmcm9tIGEgcGx1Z2luLiBUaGlzIGlzIHRvIGNvdmVyIHNvbWUgY3VycmVudCBzZXR1cHMgZm9yIHBlb3BsZSB1c2luZyBwbHVnaW5zIG9yIHByZWZlcnJpbmcgdG9cbiAgICAgIC8vIGZlZWQgdGhlIENMSSBjcmVkZW50aWFscyB3aGljaCBhcmUgc3VmZmljaWVudCBieSB0aGVtc2VsdmVzLiBQcmVmZXIgdG8gYXNzdW1lIHRoZSBjb3JyZWN0IHJvbGUgaWYgd2UgY2FuLFxuICAgICAgLy8gYnV0IGlmIHdlIGNhbid0IHRoZW4gbGV0J3MganVzdCB0cnkgd2l0aCBhdmFpbGFibGUgY3JlZGVudGlhbHMgYW55d2F5LlxuICAgICAgaWYgKGJhc2VDcmVkcy5zb3VyY2UgPT09ICdjb3JyZWN0RGVmYXVsdCcgfHwgYmFzZUNyZWRzLnNvdXJjZSA9PT0gJ3BsdWdpbicpIHtcbiAgICAgICAgZGVidWcoZS5tZXNzYWdlKTtcbiAgICAgICAgd2FybmluZyhgJHtmbXRPYnRhaW5lZENyZWRlbnRpYWxzKGJhc2VDcmVkcyl9IGNvdWxkIG5vdCBiZSB1c2VkIHRvIGFzc3VtZSAnJHtvcHRpb25zLmFzc3VtZVJvbGVBcm59JywgYnV0IGFyZSBmb3IgdGhlIHJpZ2h0IGFjY291bnQuIFByb2NlZWRpbmcgYW55d2F5LmApO1xuICAgICAgICByZXR1cm4gbmV3IFNESyhiYXNlQ3JlZHMuY3JlZGVudGlhbHMsIGVudi5yZWdpb24sIHRoaXMuc2RrT3B0aW9ucyk7XG4gICAgICB9XG5cbiAgICAgIHRocm93IGU7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgcGFydGl0aW9uIHRoYXQgYmFzZSBjcmVkZW50aWFscyBhcmUgZm9yXG4gICAqXG4gICAqIFJldHVybnMgYHVuZGVmaW5lZGAgaWYgdGhlcmUgYXJlIG5vIGJhc2UgY3JlZGVudGlhbHMuXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgYmFzZUNyZWRlbnRpYWxzUGFydGl0aW9uKGVudmlyb25tZW50OiBjeGFwaS5FbnZpcm9ubWVudCwgbW9kZTogTW9kZSk6IFByb21pc2U8c3RyaW5nIHwgdW5kZWZpbmVkPiB7XG4gICAgY29uc3QgZW52ID0gYXdhaXQgdGhpcy5yZXNvbHZlRW52aXJvbm1lbnQoZW52aXJvbm1lbnQpO1xuICAgIGNvbnN0IGJhc2VDcmVkcyA9IGF3YWl0IHRoaXMub2J0YWluQmFzZUNyZWRlbnRpYWxzKGVudi5hY2NvdW50LCBtb2RlKTtcbiAgICBpZiAoYmFzZUNyZWRzLnNvdXJjZSA9PT0gJ25vbmUnKSB7IHJldHVybiB1bmRlZmluZWQ7IH1cbiAgICByZXR1cm4gKGF3YWl0IG5ldyBTREsoYmFzZUNyZWRzLmNyZWRlbnRpYWxzLCBlbnYucmVnaW9uLCB0aGlzLnNka09wdGlvbnMpLmN1cnJlbnRBY2NvdW50KCkpLnBhcnRpdGlvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNvbHZlIHRoZSBlbnZpcm9ubWVudCBmb3IgYSBzdGFja1xuICAgKlxuICAgKiBSZXBsYWNlcyB0aGUgbWFnaWMgdmFsdWVzIGBVTktOT1dOX1JFR0lPTmAgYW5kIGBVTktOT1dOX0FDQ09VTlRgXG4gICAqIHdpdGggdGhlIGRlZmF1bHRzIGZvciB0aGUgY3VycmVudCBTREsgY29uZmlndXJhdGlvbiAoYH4vLmF3cy9jb25maWdgIG9yXG4gICAqIG90aGVyd2lzZSkuXG4gICAqXG4gICAqIEl0IGlzIGFuIGVycm9yIGlmIGBVTktOT1dOX0FDQ09VTlRgIGlzIHVzZWQgYnV0IHRoZSB1c2VyIGhhc24ndCBjb25maWd1cmVkXG4gICAqIGFueSBTREsgY3JlZGVudGlhbHMuXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgcmVzb2x2ZUVudmlyb25tZW50KGVudjogY3hhcGkuRW52aXJvbm1lbnQpOiBQcm9taXNlPGN4YXBpLkVudmlyb25tZW50PiB7XG4gICAgY29uc3QgcmVnaW9uID0gZW52LnJlZ2lvbiAhPT0gY3hhcGkuVU5LTk9XTl9SRUdJT04gPyBlbnYucmVnaW9uIDogdGhpcy5kZWZhdWx0UmVnaW9uO1xuICAgIGNvbnN0IGFjY291bnQgPSBlbnYuYWNjb3VudCAhPT0gY3hhcGkuVU5LTk9XTl9BQ0NPVU5UID8gZW52LmFjY291bnQgOiAoYXdhaXQgdGhpcy5kZWZhdWx0QWNjb3VudCgpKT8uYWNjb3VudElkO1xuXG4gICAgaWYgKCFhY2NvdW50KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byByZXNvbHZlIEFXUyBhY2NvdW50IHRvIHVzZS4gSXQgbXVzdCBiZSBlaXRoZXIgY29uZmlndXJlZCB3aGVuIHlvdSBkZWZpbmUgeW91ciBDREsgb3IgdGhyb3VnaCB0aGUgZW52aXJvbm1lbnQnKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgcmVnaW9uLFxuICAgICAgYWNjb3VudCxcbiAgICAgIG5hbWU6IGN4YXBpLkVudmlyb25tZW50VXRpbHMuZm9ybWF0KGFjY291bnQsIHJlZ2lvbiksXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgYWNjb3VudCB3ZSdkIGF1dGggaW50byBpZiB3ZSB1c2VkIGRlZmF1bHQgY3JlZGVudGlhbHMuXG4gICAqXG4gICAqIERlZmF1bHQgY3JlZGVudGlhbHMgYXJlIHRoZSBzZXQgb2YgYW1iaWVudGx5IGNvbmZpZ3VyZWQgY3JlZGVudGlhbHMgdXNpbmdcbiAgICogb25lIG9mIHRoZSBlbnZpcm9ubWVudCB2YXJpYWJsZXMsIG9yIH4vLmF3cy9jcmVkZW50aWFscywgb3IgdGhlICpvbmUqXG4gICAqIHByb2ZpbGUgdGhhdCB3YXMgcGFzc2VkIGludG8gdGhlIENMSS5cbiAgICpcbiAgICogTWlnaHQgcmV0dXJuIHVuZGVmaW5lZCBpZiB0aGVyZSBhcmUgbm8gZGVmYXVsdC9hbWJpZW50IGNyZWRlbnRpYWxzXG4gICAqIGF2YWlsYWJsZSAoaW4gd2hpY2ggY2FzZSB0aGUgdXNlciBzaG91bGQgYmV0dGVyIGhvcGUgdGhleSBoYXZlXG4gICAqIGNyZWRlbnRpYWwgcGx1Z2lucyBjb25maWd1cmVkKS5cbiAgICpcbiAgICogVXNlcyBhIGNhY2hlIHRvIGF2b2lkIFNUUyBjYWxscyBpZiB3ZSBkb24ndCBuZWVkICdlbS5cbiAgICovXG4gIHB1YmxpYyBkZWZhdWx0QWNjb3VudCgpOiBQcm9taXNlPEFjY291bnQgfCB1bmRlZmluZWQ+IHtcbiAgICByZXR1cm4gY2FjaGVkKHRoaXMsIENBQ0hFRF9BQ0NPVU5ULCBhc3luYyAoKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBjcmVkcyA9IGF3YWl0IHRoaXMuZGVmYXVsdENyZWRlbnRpYWxzKCk7XG5cbiAgICAgICAgY29uc3QgYWNjZXNzS2V5SWQgPSBjcmVkcy5hY2Nlc3NLZXlJZDtcbiAgICAgICAgaWYgKCFhY2Nlc3NLZXlJZCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIHJlc29sdmUgQVdTIGNyZWRlbnRpYWxzIChzZXR1cCB3aXRoIFwiYXdzIGNvbmZpZ3VyZVwiKScpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IG5ldyBTREsoY3JlZHMsIHRoaXMuZGVmYXVsdFJlZ2lvbiwgdGhpcy5zZGtPcHRpb25zKS5jdXJyZW50QWNjb3VudCgpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBkZWJ1ZygnVW5hYmxlIHRvIGRldGVybWluZSB0aGUgZGVmYXVsdCBBV1MgYWNjb3VudDonLCBlKTtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgY3JlZGVudGlhbHMgZm9yIHRoZSBnaXZlbiBhY2NvdW50IElEIGluIHRoZSBnaXZlbiBtb2RlXG4gICAqXG4gICAqIDEuIFVzZSB0aGUgZGVmYXVsdCBjcmVkZW50aWFscyBpZiB0aGUgZGVzdGluYXRpb24gYWNjb3VudCBtYXRjaGVzIHRoZVxuICAgKiAgICBjdXJyZW50IGNyZWRlbnRpYWxzJyBhY2NvdW50LlxuICAgKiAyLiBPdGhlcndpc2UgdHJ5IGFsbCBjcmVkZW50aWFsIHBsdWdpbnMuXG4gICAqIDMuIEZhaWwgaWYgbmVpdGhlciBvZiB0aGVzZSB5aWVsZCBhbnkgY3JlZGVudGlhbHMuXG4gICAqIDQuIFJldHVybiBhIGZhaWx1cmUgaWYgYW55IG9mIHRoZW0gcmV0dXJuZWQgY3JlZGVudGlhbHNcbiAgICovXG4gIHByaXZhdGUgYXN5bmMgb2J0YWluQmFzZUNyZWRlbnRpYWxzKGFjY291bnRJZDogc3RyaW5nLCBtb2RlOiBNb2RlKTogUHJvbWlzZTxPYnRhaW5CYXNlQ3JlZGVudGlhbHNSZXN1bHQ+IHtcbiAgICAvLyBGaXJzdCB0cnkgJ2N1cnJlbnQnIGNyZWRlbnRpYWxzXG4gICAgY29uc3QgZGVmYXVsdEFjY291bnRJZCA9IChhd2FpdCB0aGlzLmRlZmF1bHRBY2NvdW50KCkpPy5hY2NvdW50SWQ7XG4gICAgaWYgKGRlZmF1bHRBY2NvdW50SWQgPT09IGFjY291bnRJZCkge1xuICAgICAgcmV0dXJuIHsgc291cmNlOiAnY29ycmVjdERlZmF1bHQnLCBjcmVkZW50aWFsczogYXdhaXQgdGhpcy5kZWZhdWx0Q3JlZGVudGlhbHMoKSB9O1xuICAgIH1cblxuICAgIC8vIFRoZW4gdHJ5IHRoZSBwbHVnaW5zXG4gICAgY29uc3QgcGx1Z2luQ3JlZHMgPSBhd2FpdCB0aGlzLnBsdWdpbnMuZmV0Y2hDcmVkZW50aWFsc0ZvcihhY2NvdW50SWQsIG1vZGUpO1xuICAgIGlmIChwbHVnaW5DcmVkcykge1xuICAgICAgcmV0dXJuIHsgc291cmNlOiAncGx1Z2luJywgLi4ucGx1Z2luQ3JlZHMgfTtcbiAgICB9XG5cbiAgICAvLyBGYWxsIGJhY2sgdG8gZGVmYXVsdCBjcmVkZW50aWFscyB3aXRoIGEgbm90ZSB0aGF0IHRoZXkncmUgbm90IHRoZSByaWdodCBvbmVzIHlldFxuICAgIGlmIChkZWZhdWx0QWNjb3VudElkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHNvdXJjZTogJ2luY29ycmVjdERlZmF1bHQnLFxuICAgICAgICBhY2NvdW50SWQ6IGRlZmF1bHRBY2NvdW50SWQsXG4gICAgICAgIGNyZWRlbnRpYWxzOiBhd2FpdCB0aGlzLmRlZmF1bHRDcmVkZW50aWFscygpLFxuICAgICAgICB1bnVzZWRQbHVnaW5zOiB0aGlzLnBsdWdpbnMuYXZhaWxhYmxlUGx1Z2luTmFtZXMsXG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIEFwcGFyZW50bHkgd2UgZGlkbid0IGZpbmQgYW55IGF0IGFsbFxuICAgIHJldHVybiB7XG4gICAgICBzb3VyY2U6ICdub25lJyxcbiAgICAgIHVudXNlZFBsdWdpbnM6IHRoaXMucGx1Z2lucy5hdmFpbGFibGVQbHVnaW5OYW1lcyxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFJlc29sdmUgdGhlIGRlZmF1bHQgY2hhaW4gdG8gdGhlIGZpcnN0IHNldCBvZiBjcmVkZW50aWFscyB0aGF0IGlzIGF2YWlsYWJsZVxuICAgKi9cbiAgcHJpdmF0ZSBkZWZhdWx0Q3JlZGVudGlhbHMoKTogUHJvbWlzZTxBV1MuQ3JlZGVudGlhbHM+IHtcbiAgICByZXR1cm4gY2FjaGVkKHRoaXMsIENBQ0hFRF9ERUZBVUxUX0NSRURFTlRJQUxTLCAoKSA9PiB7XG4gICAgICBkZWJ1ZygnUmVzb2x2aW5nIGRlZmF1bHQgY3JlZGVudGlhbHMnKTtcbiAgICAgIHJldHVybiB0aGlzLmRlZmF1bHRDaGFpbi5yZXNvbHZlUHJvbWlzZSgpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBhbiBTREsgd2hpY2ggdXNlcyBhc3N1bWVkIHJvbGUgY3JlZGVudGlhbHNcbiAgICpcbiAgICogVGhlIGJhc2UgY3JlZGVudGlhbHMgdXNlZCB0byByZXRyaWV2ZSB0aGUgYXNzdW1lZCByb2xlIGNyZWRlbnRpYWxzIHdpbGwgYmUgdGhlXG4gICAqIHNhbWUgY3JlZGVudGlhbHMgcmV0dXJuZWQgYnkgb2J0YWluQ3JlZGVudGlhbHMgaWYgYW4gZW52aXJvbm1lbnQgYW5kIG1vZGUgaXMgcGFzc2VkLFxuICAgKiBvdGhlcndpc2UgaXQgd2lsbCBiZSB0aGUgY3VycmVudCBjcmVkZW50aWFscy5cbiAgICovXG4gIHByaXZhdGUgYXN5bmMgd2l0aEFzc3VtZWRSb2xlKFxuICAgIG1hc3RlckNyZWRlbnRpYWxzOiBFeGNsdWRlPE9idGFpbkJhc2VDcmVkZW50aWFsc1Jlc3VsdCwgeyBzb3VyY2U6ICdub25lJyB9PixcbiAgICByb2xlQXJuOiBzdHJpbmcsXG4gICAgZXh0ZXJuYWxJZDogc3RyaW5nIHwgdW5kZWZpbmVkLFxuICAgIHJlZ2lvbjogc3RyaW5nIHwgdW5kZWZpbmVkKSB7XG4gICAgZGVidWcoYEFzc3VtaW5nIHJvbGUgJyR7cm9sZUFybn0nLmApO1xuXG4gICAgcmVnaW9uID0gcmVnaW9uID8/IHRoaXMuZGVmYXVsdFJlZ2lvbjtcblxuICAgIGNvbnN0IGNyZWRzID0gbmV3IEFXUy5DaGFpbmFibGVUZW1wb3JhcnlDcmVkZW50aWFscyh7XG4gICAgICBwYXJhbXM6IHtcbiAgICAgICAgUm9sZUFybjogcm9sZUFybixcbiAgICAgICAgLi4uZXh0ZXJuYWxJZCA/IHsgRXh0ZXJuYWxJZDogZXh0ZXJuYWxJZCB9IDoge30sXG4gICAgICAgIFJvbGVTZXNzaW9uTmFtZTogYGF3cy1jZGstJHtzYWZlVXNlcm5hbWUoKX1gLFxuICAgICAgfSxcbiAgICAgIHN0c0NvbmZpZzoge1xuICAgICAgICByZWdpb24sXG4gICAgICAgIC4uLnRoaXMuc2RrT3B0aW9ucyxcbiAgICAgIH0sXG4gICAgICBtYXN0ZXJDcmVkZW50aWFsczogbWFzdGVyQ3JlZGVudGlhbHMuY3JlZGVudGlhbHMsXG4gICAgfSk7XG5cbiAgICByZXR1cm4gbmV3IFNESyhjcmVkcywgcmVnaW9uLCB0aGlzLnNka09wdGlvbnMsIHtcbiAgICAgIGFzc3VtZVJvbGVDcmVkZW50aWFsc1NvdXJjZURlc2NyaXB0aW9uOiBmbXRPYnRhaW5lZENyZWRlbnRpYWxzKG1hc3RlckNyZWRlbnRpYWxzKSxcbiAgICB9KTtcbiAgfVxufVxuXG4vKipcbiAqIEFuIEFXUyBhY2NvdW50XG4gKlxuICogQW4gQVdTIGFjY291bnQgYWx3YXlzIGV4aXN0cyBpbiBvbmx5IG9uZSBwYXJ0aXRpb24uIFVzdWFsbHkgd2UgZG9uJ3QgY2FyZSBhYm91dFxuICogdGhlIHBhcnRpdGlvbiwgYnV0IHdoZW4gd2UgbmVlZCB0byBmb3JtIEFSTnMgd2UgZG8uXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQWNjb3VudCB7XG4gIC8qKlxuICAgKiBUaGUgYWNjb3VudCBudW1iZXJcbiAgICovXG4gIHJlYWRvbmx5IGFjY291bnRJZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgcGFydGl0aW9uICgnYXdzJyBvciAnYXdzLWNuJyBvciBvdGhlcndpc2UpXG4gICAqL1xuICByZWFkb25seSBwYXJ0aXRpb246IHN0cmluZztcbn1cblxuY29uc3QgREVGQVVMVF9DT05ORUNUSU9OX1RJTUVPVVQgPSAxMDAwMDtcbmNvbnN0IERFRkFVTFRfVElNRU9VVCA9IDMwMDAwMDtcblxuLyoqXG4gKiBHZXQgSFRUUCBvcHRpb25zIGZvciB0aGUgU0RLXG4gKlxuICogUmVhZCBmcm9tIHVzZXIgaW5wdXQgb3IgZW52aXJvbm1lbnQgdmFyaWFibGVzLlxuICpcbiAqIFJldHVybnMgYSBjb21wbGV0ZSBgQ29uZmlndXJhdGlvbk9wdGlvbnNgIG9iamVjdCBiZWNhdXNlIHRoYXQncyB3aGVyZVxuICogYGN1c3RvbVVzZXJBZ2VudGAgbGl2ZXMsIGJ1dCBgaHR0cE9wdGlvbnNgIGlzIHRoZSBtb3N0IGltcG9ydGFudCBhdHRyaWJ1dGUuXG4gKi9cbmZ1bmN0aW9uIHBhcnNlSHR0cE9wdGlvbnMob3B0aW9uczogU2RrSHR0cE9wdGlvbnMpIHtcbiAgY29uc3QgY29uZmlnOiBDb25maWd1cmF0aW9uT3B0aW9ucyA9IHt9O1xuICBjb25maWcuaHR0cE9wdGlvbnMgPSB7fTtcblxuICBjb25maWcuaHR0cE9wdGlvbnMuY29ubmVjdFRpbWVvdXQgPSBERUZBVUxUX0NPTk5FQ1RJT05fVElNRU9VVDtcbiAgY29uZmlnLmh0dHBPcHRpb25zLnRpbWVvdXQgPSBERUZBVUxUX1RJTUVPVVQ7XG5cbiAgbGV0IHVzZXJBZ2VudCA9IG9wdGlvbnMudXNlckFnZW50O1xuICBpZiAodXNlckFnZW50ID09IG51bGwpIHtcbiAgICAvLyBGaW5kIHRoZSBwYWNrYWdlLmpzb24gZnJvbSB0aGUgbWFpbiB0b29sa2l0XG4gICAgY29uc3QgcGtnID0gSlNPTi5wYXJzZShyZWFkSWZQb3NzaWJsZShwYXRoLmpvaW4oX19kaXJuYW1lLCAnLi4nLCAnLi4nLCAnLi4nLCAncGFja2FnZS5qc29uJykpID8/ICd7fScpO1xuICAgIHVzZXJBZ2VudCA9IGAke3BrZy5uYW1lfS8ke3BrZy52ZXJzaW9ufWA7XG4gIH1cbiAgY29uZmlnLmN1c3RvbVVzZXJBZ2VudCA9IHVzZXJBZ2VudDtcblxuICBjb25zdCBwcm94eUFkZHJlc3MgPSBvcHRpb25zLnByb3h5QWRkcmVzcyB8fCBodHRwc1Byb3h5RnJvbUVudmlyb25tZW50KCk7XG4gIGNvbnN0IGNhQnVuZGxlUGF0aCA9IG9wdGlvbnMuY2FCdW5kbGVQYXRoIHx8IGNhQnVuZGxlUGF0aEZyb21FbnZpcm9ubWVudCgpO1xuXG4gIGlmIChwcm94eUFkZHJlc3MgJiYgY2FCdW5kbGVQYXRoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBBdCB0aGUgbW9tZW50LCBjYW5ub3Qgc3BlY2lmeSBQcm94eSAoJHtwcm94eUFkZHJlc3N9KSBhbmQgQ0EgQnVuZGxlICgke2NhQnVuZGxlUGF0aH0pIGF0IHRoZSBzYW1lIHRpbWUuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vYXdzL2F3cy1jZGsvaXNzdWVzLzU4MDRgKTtcbiAgICAvLyBNYXliZSBpdCdzIHBvc3NpYmxlIGFmdGVyIGFsbCwgYnV0IEkndmUgYmVlbiBzdGFyaW5nIGF0XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL1Rvb1RhbGxOYXRlL25vZGUtcHJveHktYWdlbnQvYmxvYi9tYXN0ZXIvaW5kZXguanMjTDc5XG4gICAgLy8gYSB3aGlsZSBub3cgdHJ5aW5nIHRvIGZpZ3VyZSBvdXQgd2hhdCB0byBwYXNzIGluIHNvIHRoYXQgdGhlIHVuZGVybHlpbmcgQWdlbnRcbiAgICAvLyBvYmplY3Qgd2lsbCBnZXQgdGhlICdjYScgYXJndW1lbnQuIEl0J3Mgbm90IHRyaXZpYWwgYW5kIEkgZG9uJ3Qgd2FudCB0byByaXNrIGl0LlxuICB9XG5cbiAgaWYgKHByb3h5QWRkcmVzcykgeyAvLyBJZ25vcmUgZW1wdHkgc3RyaW5nIG9uIHB1cnBvc2VcbiAgICAvLyBodHRwczovL2F3cy5hbWF6b24uY29tL2Jsb2dzL2RldmVsb3Blci91c2luZy10aGUtYXdzLXNkay1mb3ItamF2YXNjcmlwdC1mcm9tLWJlaGluZC1hLXByb3h5L1xuICAgIGRlYnVnKCdVc2luZyBwcm94eSBzZXJ2ZXI6ICVzJywgcHJveHlBZGRyZXNzKTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXJlcXVpcmUtaW1wb3J0c1xuICAgIGNvbnN0IFByb3h5QWdlbnQ6IGFueSA9IHJlcXVpcmUoJ3Byb3h5LWFnZW50Jyk7XG4gICAgY29uZmlnLmh0dHBPcHRpb25zLmFnZW50ID0gbmV3IFByb3h5QWdlbnQocHJveHlBZGRyZXNzKTtcbiAgfVxuICBpZiAoY2FCdW5kbGVQYXRoKSB7XG4gICAgZGVidWcoJ1VzaW5nIENBIGJ1bmRsZSBwYXRoOiAlcycsIGNhQnVuZGxlUGF0aCk7XG4gICAgY29uZmlnLmh0dHBPcHRpb25zLmFnZW50ID0gbmV3IGh0dHBzLkFnZW50KHtcbiAgICAgIGNhOiByZWFkSWZQb3NzaWJsZShjYUJ1bmRsZVBhdGgpLFxuICAgICAga2VlcEFsaXZlOiB0cnVlLFxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIGNvbmZpZztcbn1cblxuLyoqXG4gKiBGaW5kIGFuZCByZXR1cm4gdGhlIGNvbmZpZ3VyZWQgSFRUUFMgcHJveHkgYWRkcmVzc1xuICovXG5mdW5jdGlvbiBodHRwc1Byb3h5RnJvbUVudmlyb25tZW50KCk6IHN0cmluZyB8IHVuZGVmaW5lZCB7XG4gIGlmIChwcm9jZXNzLmVudi5odHRwc19wcm94eSkge1xuICAgIHJldHVybiBwcm9jZXNzLmVudi5odHRwc19wcm94eTtcbiAgfVxuICBpZiAocHJvY2Vzcy5lbnYuSFRUUFNfUFJPWFkpIHtcbiAgICByZXR1cm4gcHJvY2Vzcy5lbnYuSFRUUFNfUFJPWFk7XG4gIH1cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBGaW5kIGFuZCByZXR1cm4gYSBDQSBjZXJ0aWZpY2F0ZSBidW5kbGUgcGF0aCB0byBiZSBwYXNzZWQgaW50byB0aGUgU0RLLlxuICovXG5mdW5jdGlvbiBjYUJ1bmRsZVBhdGhGcm9tRW52aXJvbm1lbnQoKTogc3RyaW5nIHwgdW5kZWZpbmVkIHtcbiAgaWYgKHByb2Nlc3MuZW52LmF3c19jYV9idW5kbGUpIHtcbiAgICByZXR1cm4gcHJvY2Vzcy5lbnYuYXdzX2NhX2J1bmRsZTtcbiAgfVxuICBpZiAocHJvY2Vzcy5lbnYuQVdTX0NBX0JVTkRMRSkge1xuICAgIHJldHVybiBwcm9jZXNzLmVudi5BV1NfQ0FfQlVORExFO1xuICB9XG4gIHJldHVybiB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogUmVhZCBhIGZpbGUgaWYgaXQgZXhpc3RzLCBvciByZXR1cm4gdW5kZWZpbmVkXG4gKlxuICogTm90IGFzeW5jIGJlY2F1c2UgaXQgaXMgdXNlZCBpbiB0aGUgY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gcmVhZElmUG9zc2libGUoZmlsZW5hbWU6IHN0cmluZyk6IHN0cmluZyB8IHVuZGVmaW5lZCB7XG4gIHRyeSB7XG4gICAgaWYgKCFmcy5wYXRoRXhpc3RzU3luYyhmaWxlbmFtZSkpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuICAgIHJldHVybiBmcy5yZWFkRmlsZVN5bmMoZmlsZW5hbWUsIHsgZW5jb2Rpbmc6ICd1dGYtOCcgfSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBkZWJ1ZyhlKTtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG59XG5cbi8qKlxuICogUmV0dXJuIHRoZSB1c2VybmFtZSB3aXRoIGNoYXJhY3RlcnMgaW52YWxpZCBmb3IgYSBSb2xlU2Vzc2lvbk5hbWUgcmVtb3ZlZFxuICpcbiAqIEBzZWUgaHR0cHM6Ly9kb2NzLmF3cy5hbWF6b24uY29tL1NUUy9sYXRlc3QvQVBJUmVmZXJlbmNlL0FQSV9Bc3N1bWVSb2xlLmh0bWwjQVBJX0Fzc3VtZVJvbGVfUmVxdWVzdFBhcmFtZXRlcnNcbiAqL1xuZnVuY3Rpb24gc2FmZVVzZXJuYW1lKCkge1xuICByZXR1cm4gb3MudXNlckluZm8oKS51c2VybmFtZS5yZXBsYWNlKC9bXlxcdys9LC5ALV0vZywgJ0AnKTtcbn1cblxuLyoqXG4gKiBPcHRpb25zIGZvciBvYnRhaW5pbmcgY3JlZGVudGlhbHMgZm9yIGFuIGVudmlyb25tZW50XG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQ3JlZGVudGlhbHNPcHRpb25zIHtcbiAgLyoqXG4gICAqIFRoZSBBUk4gb2YgdGhlIHJvbGUgdGhhdCBuZWVkcyB0byBiZSBhc3N1bWVkLCBpZiBhbnlcbiAgICovXG4gIHJlYWRvbmx5IGFzc3VtZVJvbGVBcm4/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIEV4dGVybmFsIElEIHJlcXVpcmVkIHRvIGFzc3VtZSB0aGUgZ2l2ZW4gcm9sZS5cbiAgICovXG4gIHJlYWRvbmx5IGFzc3VtZVJvbGVFeHRlcm5hbElkPzogc3RyaW5nO1xufVxuXG4vKipcbiAqIFJlc3VsdCBvZiBvYnRhaW5pbmcgYmFzZSBjcmVkZW50aWFsc1xuICovXG50eXBlIE9idGFpbkJhc2VDcmVkZW50aWFsc1Jlc3VsdCA9XG4gIHsgc291cmNlOiAnY29ycmVjdERlZmF1bHQnOyBjcmVkZW50aWFsczogQVdTLkNyZWRlbnRpYWxzIH1cbiAgfCB7IHNvdXJjZTogJ3BsdWdpbic7IHBsdWdpbk5hbWU6IHN0cmluZywgY3JlZGVudGlhbHM6IEFXUy5DcmVkZW50aWFscyB9XG4gIHwgeyBzb3VyY2U6ICdpbmNvcnJlY3REZWZhdWx0JzsgY3JlZGVudGlhbHM6IEFXUy5DcmVkZW50aWFsczsgYWNjb3VudElkOiBzdHJpbmc7IHVudXNlZFBsdWdpbnM6IHN0cmluZ1tdIH1cbiAgfCB7IHNvdXJjZTogJ25vbmUnOyB1bnVzZWRQbHVnaW5zOiBzdHJpbmdbXSB9O1xuXG4vKipcbiAqIElzb2xhdGluZyB0aGUgY29kZSB0aGF0IHRyYW5zbGF0ZXMgY2FsY3VsYXRpb24gZXJyb3JzIGludG8gaHVtYW4gZXJyb3IgbWVzc2FnZXNcbiAqXG4gKiBXZSBjb3ZlciB0aGUgZm9sbG93aW5nIGNhc2VzOlxuICpcbiAqIC0gTm8gY3JlZGVudGlhbHMgYXJlIGF2YWlsYWJsZSBhdCBhbGxcbiAqIC0gRGVmYXVsdCBjcmVkZW50aWFscyBhcmUgZm9yIHRoZSB3cm9uZyBhY2NvdW50XG4gKi9cbmZ1bmN0aW9uIGZtdE9idGFpbkNyZWRlbnRpYWxzRXJyb3IodGFyZ2V0QWNjb3VudElkOiBzdHJpbmcsIG9idGFpblJlc3VsdDogT2J0YWluQmFzZUNyZWRlbnRpYWxzUmVzdWx0ICYgeyBzb3VyY2U6ICdub25lJyB8ICdpbmNvcnJlY3REZWZhdWx0JyB9KTogc3RyaW5nIHtcbiAgY29uc3QgbXNnID0gW2BOZWVkIHRvIHBlcmZvcm0gQVdTIGNhbGxzIGZvciBhY2NvdW50ICR7dGFyZ2V0QWNjb3VudElkfWBdO1xuICBzd2l0Y2ggKG9idGFpblJlc3VsdC5zb3VyY2UpIHtcbiAgICBjYXNlICdpbmNvcnJlY3REZWZhdWx0JzpcbiAgICAgIG1zZy5wdXNoKGBidXQgdGhlIGN1cnJlbnQgY3JlZGVudGlhbHMgYXJlIGZvciAke29idGFpblJlc3VsdC5hY2NvdW50SWR9YCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdub25lJzpcbiAgICAgIG1zZy5wdXNoKCdidXQgbm8gY3JlZGVudGlhbHMgaGF2ZSBiZWVuIGNvbmZpZ3VyZWQnKTtcbiAgfVxuICBpZiAob2J0YWluUmVzdWx0LnVudXNlZFBsdWdpbnMubGVuZ3RoID4gMCkge1xuICAgIG1zZy5wdXNoKGBhbmQgbm9uZSBvZiB0aGVzZSBwbHVnaW5zIGZvdW5kIGFueTogJHtvYnRhaW5SZXN1bHQudW51c2VkUGx1Z2lucy5qb2luKCcsICcpfWApO1xuICB9XG4gIHJldHVybiBtc2cuam9pbignLCAnKTtcbn1cblxuLyoqXG4gKiBGb3JtYXQgYSBtZXNzYWdlIGluZGljYXRpbmcgd2hlcmUgd2UgZ290IGJhc2UgY3JlZGVudGlhbHMgZm9yIHRoZSBhc3N1bWUgcm9sZVxuICpcbiAqIFdlIGNvdmVyIHRoZSBmb2xsb3dpbmcgY2FzZXM6XG4gKlxuICogLSBEZWZhdWx0IGNyZWRlbnRpYWxzIGZvciB0aGUgcmlnaHQgYWNjb3VudFxuICogLSBEZWZhdWx0IGNyZWRlbnRpYWxzIGZvciB0aGUgd3JvbmcgYWNjb3VudFxuICogLSBDcmVkZW50aWFscyByZXR1cm5lZCBmcm9tIGEgcGx1Z2luXG4gKi9cbmZ1bmN0aW9uIGZtdE9idGFpbmVkQ3JlZGVudGlhbHMoXG4gIG9idGFpblJlc3VsdDogRXhjbHVkZTxPYnRhaW5CYXNlQ3JlZGVudGlhbHNSZXN1bHQsIHsgc291cmNlOiAnbm9uZScgfT4pOiBzdHJpbmcge1xuICBzd2l0Y2ggKG9idGFpblJlc3VsdC5zb3VyY2UpIHtcbiAgICBjYXNlICdjb3JyZWN0RGVmYXVsdCc6XG4gICAgICByZXR1cm4gJ2N1cnJlbnQgY3JlZGVudGlhbHMnO1xuICAgIGNhc2UgJ3BsdWdpbic6XG4gICAgICByZXR1cm4gYGNyZWRlbnRpYWxzIHJldHVybmVkIGJ5IHBsdWdpbiAnJHtvYnRhaW5SZXN1bHQucGx1Z2luTmFtZX0nYDtcbiAgICBjYXNlICdpbmNvcnJlY3REZWZhdWx0JzpcbiAgICAgIGNvbnN0IG1zZyA9IFtdO1xuICAgICAgbXNnLnB1c2goYGN1cnJlbnQgY3JlZGVudGlhbHMgKHdoaWNoIGFyZSBmb3IgYWNjb3VudCAke29idGFpblJlc3VsdC5hY2NvdW50SWR9YCk7XG5cbiAgICAgIGlmIChvYnRhaW5SZXN1bHQudW51c2VkUGx1Z2lucy5sZW5ndGggPiAwKSB7XG4gICAgICAgIG1zZy5wdXNoKGAsIGFuZCBub25lIG9mIHRoZSBmb2xsb3dpbmcgcGx1Z2lucyBwcm92aWRlZCBjcmVkZW50aWFsczogJHtvYnRhaW5SZXN1bHQudW51c2VkUGx1Z2lucy5qb2luKCcsICcpfWApO1xuICAgICAgfVxuICAgICAgbXNnLnB1c2goJyknKTtcblxuICAgICAgcmV0dXJuIG1zZy5qb2luKCcnKTtcbiAgfVxufVxuIl19